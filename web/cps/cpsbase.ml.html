<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>cpsbase.ml</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -I /usr/share/texmf/tex/latex/misc ocamlweb.sty cpsbase.ml.tex -->
<!--CUT DEF section 1 --><!--TOC section Module Cpsbase-->
<H2 CLASS="section"><!--SEC ANCHOR -->Module Cpsbase</H2><!--SEC END --><P>
<B>1.</B> 
<A NAME="src/cps/cpsbase.ml:0"></A><A NAME="src/cps/cpsbase.ml:43"></A>These definitions originates from the "compiling with
continuations, continued" paper, by Andrew Kennedy (we currently
use the simplified, non-graph version).</P><P>CPS (for continuation passing style) puts constraints on functional
programs so that a function <I>f</I> never returns; instead it is passed
a continuation <I>k</I>, which is a function that represents what is
executed on <I>f</I> has finished its execution. So instead of returning
a value <I>x</I>, <I>f</I> "returns" by calling <I>k</I>(<I>x</I>). CPS style makes
returning from functions, and more generally control flow,
explicit, at the expense or more verbosity.</P><P>This file presents a particular representation of CPS terms that
separates continuations, calling a continuations, variables holding
continations from respectively normal functions, normal function
calls, and normal variables. This distinction allows to compile the
CPS program using a stack (see the <code><span style="color: #228b22; ">Cpsllvm</span></code> module for an
implementation of that). </P><P>The representation also forces all values (including constants such
as integers) to be held in variables, which simplify later
transformation algorithms.</P><P>Finally, we implement mutable links between variables, the terms
that use and bind a variable, and between a term and its enclosing
parent. This allows efficient transformation of CPS terms.
<BR>
</P><!--TOC subsection Term representation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Term representation</H3><!--SEC END --><P>First we present the logical structure of terms. 
<BR><B>2.</B> 
<A NAME="src/cps/cpsbase.ml:1478"></A>Following module <code><span style="color: #228b22; ">Cpsvar</span></code>, we have different structures for
variables (to used where the variable is bound) from occurrence of a
variable (to use where a variable is used). </P><P>Note that this module makes variables and continuation variables
unique, and thus avoid any need for alpha conversion. 
<BR><A NAME="src/cps/cpsbase.ml:1785"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">type</span> var = (var_desc,occur_desc) <span style="color: #228b22; ">Cpsvar.</span>variable<BR>
<span style="color: #0000ff; font-weight: bold;">and</span> occur = (var_desc,occur_desc) <span style="color: #228b22; ">Cpsvar.</span>occurrence<BR>
<span style="color: #0000ff; font-weight: bold;">and</span> cont_var = (cont_var_desc,cont_occur_desc) <span style="color: #228b22; ">Cpsvar.</span>variable<BR>
<span style="color: #0000ff; font-weight: bold;">and</span> cont_occur = (cont_var_desc,cont_occur_desc) <span style="color: #228b22; ">Cpsvar.</span>occurrence<BR></code></div><B>3.</B> 
<A NAME="src/cps/cpsbase.ml:2021"></A>The representation of CPS terms separates continuations from usual
functions. The various terms are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B><I>let</I></B> <I>x</I> = <I>primitive</I>; <I>body</I> creates a binding to a primitive
value, or to the result of a primitive operation (to be used in
body)</LI><LI CLASS="li-itemize"><B><I>let</I></B> <I>k</I>(<I>x</I>) = <I>t</I>; <I>body</I>  creates a binding to a
continuation <I>k</I>. <I>x</I> is bound in <I>t</I>, but not in <I>body</I>. The <I>k</I>
continuation variable is bound both in <I>body</I> and <I>t</I> (this allows
loops).</LI><LI CLASS="li-itemize"><I>k</I>(<I>x</I>) calls the <EM>continuation</EM> <I>k</I> with <I>x</I>. It can be
seen as a "jump with argument <I>x</I>"</LI><LI CLASS="li-itemize"><I>v</I>(<I>k</I>,<I>x</I>) calls the <EM>function</EM> <I>v</I>, <I>k</I> being the return
continuation, and <I>x</I> a parameter. <I>v</I> does not return; instead it
will call <I>k</I> with the "return value" as a parameter.</LI><LI CLASS="li-itemize"><I>halt</I>(<I>x</I>) is used only as a base case, to stop induction. Its
semantics is that it returns the value <code>x</code>, which is the result of
the computation, to the caller. </LI></UL><P> 
<BR><A NAME="src/cps/cpsbase.ml:2992"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> term_ = <BR>  
&#X2223; <span style="color: #228b22; ">Let_prim</span> <span style="color: #a52a2a; ">of</span> var × primitive × term<BR>  
&#X2223; <span style="color: #228b22; ">Let_cont</span> <span style="color: #a52a2a; ">of</span> cont_var × var × term × term<BR>  
&#X2223; <span style="color: #228b22; ">Apply_cont</span> <span style="color: #a52a2a; ">of</span> cont_occur × occur<BR>  
&#X2223; <span style="color: #228b22; ">Apply</span> <span style="color: #a52a2a; ">of</span> occur × cont_occur × occur<BR>  
&#X2223; <span style="color: #228b22; ">Halt</span> <span style="color: #a52a2a; ">of</span> occur<BR></code></div><B>4.</B> 
<A NAME="src/cps/cpsbase.ml:3188"></A>Primitive are values, or operations that return a value. The
various operations do not take values as parameters (even constants
such as int), only variables: the representation forces all values
to be bound in a variable. This allows a uniform treatment that
helps transformation passes.</P><P>The various operations are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><I>x</I>[<I>i</I>] get the <I>i</I>th element out of <I>x</I>. <I>x</I> is a variable bound to
a tuple.</LI><LI CLASS="li-itemize"><I>x</I><SUB>1</SUB> <I>op</I> <I>x</I><SUB>2</SUB> applies binary op to two arguments.</LI></UL><P>Note that there are no primitive that would allow to write <B><I>let</I></B> <I>x</I> = <I>y</I>, where <I>y</I> is a variable; thus there cannot be two
variables that directly share the same value. 
<BR><A NAME="src/cps/cpsbase.ml:3884"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> primitive =<BR>  
&#X2223; <span style="color: #228b22; ">Value</span> <span style="color: #a52a2a; ">of</span> value<BR>  
&#X2223; <span style="color: #228b22; ">Projection</span> <span style="color: #a52a2a; ">of</span> occur × <span style="color: #228b22; ">int</span><BR>  
&#X2223; <span style="color: #228b22; ">Integer_binary_op</span> <span style="color: #a52a2a; ">of</span> <span style="color: #228b22; ">Constant.</span>integer_binary_op × occur × occur<BR></code></div><B>5.</B> 
<A NAME="src/cps/cpsbase.ml:4020"></A>Values are primitive objects, held in normal variables.</P><P>Note that contrary to the source language, we can have Tuple objets
with lists of 0 or 1 element; they correspond to void * pointer and
simple pointers. <code><span style="color: #228b22; ">Void</span></code> is different from <code><span style="color: #228b22; ">Tuple</span> [ ]</code>, and <code>x</code> is
different from <code><span style="color: #228b22; ">Tuple</span> [x]</code>. 
<BR><A NAME="src/cps/cpsbase.ml:5020"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> value =<BR>  
&#X2223; <span style="color: #228b22; ">Void</span><BR>  
&#X2223; <span style="color: #228b22; ">Constant</span> <span style="color: #a52a2a; ">of</span> <span style="color: #228b22; ">Constant.</span>t<BR>  
&#X2223; <span style="color: #228b22; ">Tuple</span> <span style="color: #a52a2a; ">of</span> occur <span style="color: #228b22; ">list</span><BR>  
&#X2223; <span style="color: #228b22; ">Lambda</span> <span style="color: #a52a2a; ">of</span> cont_var × var × term</P><P></code></div>
</P><!--TOC subsection Definitions representation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Definitions representation</H3><!--SEC END --><P>This section presents the logical structure of toplevel
definitions.</P><P>The problem of top-level definitions is that a definition is really
like a term, except that the variable that it binds is global. This
introduce some redundancies, in particular concerning handling
backlinks from terms to their parent terms or definitions. The
definition structure is thus likely to be heavily changed, or even
disappear in favor of an extended notion of "top-level term". 
<BR><B>6.</B> 
<A NAME="src/cps/cpsbase.ml:5665"></A>A <code><span style="color: #0000ff; font-weight: bold;">module</span></code> is composed of a list of "toplevel definitions". Each
<code>toplevel definition</code> simultaneously defines several objects (this
allows mutually recursive definitions).</P><P>Note: Alternatively, we could maybe define a module as a list of
toplevel definitions that are all defined at the same time; this
would avoid the "list of list". 
<BR><A NAME="src/cps/cpsbase.ml:6015"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> modul = <span style="color: #228b22; ">Module</span> <span style="color: #a52a2a; ">of</span> toplevel <span style="color: #228b22; ">list</span><BR>
<span style="color: #0000ff; font-weight: bold;">and</span> toplevel = <span style="color: #228b22; ">Top</span> <span style="color: #a52a2a; ">of</span> definition <span style="color: #228b22; ">list</span><BR></code></div><B>7.</B> 
<A NAME="src/cps/cpsbase.ml:6092"></A>A <code>definition</code> binds a (global) variable to a value, with some
<code>visibility</code>. Public global variables may be used by other
modules. Private ones can be used by other definitions of the
module. Unused ones cannot be used by any code, they are used to
represent computations used only for their side effects. 
<BR><A NAME="src/cps/cpsbase.ml:6411"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> definition = visibility × definition_type<BR>
<span style="color: #0000ff; font-weight: bold;">and</span> visibility = <span style="color: #228b22; ">Public</span> <span style="color: #a52a2a; ">of</span> var &#X2223; <span style="color: #228b22; ">Private</span> <span style="color: #a52a2a; ">of</span> var &#X2223; <span style="color: #228b22; ">Unused</span></P><P></code></div>
Values may either be functions (compiled to code in .text section),
statically computed and allocated values (put in .data section), or
dynamic values, computed at initialization time and compiled into
constructors calls (.ctors and .bss). 
<BR><A NAME="src/cps/cpsbase.ml:6770"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> definition_type = <BR>  
&#X2223; <span style="color: #228b22; ">Function</span> <span style="color: #a52a2a; ">of</span> var <span style="color: #228b22; ">list</span> × term<BR>  
&#X2223; <span style="color: #228b22; ">Static_value</span> <span style="color: #a52a2a; ">of</span> value<BR>  
&#X2223; <span style="color: #228b22; ">Dynamic_value</span> <span style="color: #a52a2a; ">of</span> term<BR>  
&#X2223; <span style="color: #228b22; ">External_value</span></P><P></code></div>
</P><!--TOC subsection Backlinks and mutability for efficient operations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Backlinks and mutability for efficient operations</H3><!--SEC END --><P> 
<BR><B>8.</B> 
<A NAME="src/cps/cpsbase.ml:6970"></A>The <code>term_</code> type defines the logical structure of a term, and we
insert this structure between any two <code>term_</code>s, or between a <code>term_</code>
and its <code>definition</code>. It implements a mutable double-link between a
term and its parent, (which can be a term or a top-level
definition).</P><P>Note that a term has only one parent, and thus can appear only once
in a tree. 
<BR><A NAME="src/cps/cpsbase.ml:7339"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> term = { <span style="color: #a020f0; ">mutable</span> enclosing:enclosing; <span style="color: #a020f0; ">mutable</span> term:term_}</P><P></code></div>
Enclosing are uplinks from expressions to the enclosing expression
or toplevel definition. <code><span style="color: #228b22; ">Enclosing_uninitialized</span></code> is a temporary
state, encountered only during CPS term creation or
transformation. 
<BR><A NAME="src/cps/cpsbase.ml:7617"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> enclosing =<BR>  
&#X2223; <span style="color: #228b22; ">Enclosing_definition</span> <span style="color: #a52a2a; ">of</span> definition<BR>  
&#X2223; <span style="color: #228b22; ">Enclosing_term</span> <span style="color: #a52a2a; ">of</span> term<BR>  
&#X2223; <span style="color: #228b22; ">Enclosing_uninitialized</span><BR></code></div><B>9.</B> 
<A NAME="src/cps/cpsbase.ml:7730"></A>For now we have only implemented uplinks from variables to their
binding sites. We should hade uplinks from occurrences to the site
that use them, and do the same for continuation variables. 
<BR><A NAME="src/cps/cpsbase.ml:7931"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> var_desc = { <span style="color: #a020f0; ">mutable</span> binding_site_var:enclosing; }<BR>
<span style="color: #0000ff; font-weight: bold;">and</span> occur_desc = <span style="color: #228b22; ">unit</span><BR>
<span style="color: #0000ff; font-weight: bold;">and</span> cont_var_desc = <span style="color: #228b22; ">unit</span><BR>
<span style="color: #0000ff; font-weight: bold;">and</span> cont_occur_desc = <span style="color: #228b22; ">unit</span></P><P></code></div>
We also instantiate Cpsvar for variables and continuation
variables; see <code><span style="color: #228b22; ">Cpsvar</span></code> for details about this module. 
<BR><A NAME="src/cps/cpsbase.ml:8183"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Var</span> = <span style="color: #228b22; ">Cpsvar.Make</span>(<span style="color: #0000ff; font-weight: bold;">struct</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> variable_description = var_desc<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> occurrence_description = occur_desc<BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> var_prefix = <span style="color: #8b2252; ">"x"</span><BR>
<span style="color: #0000ff; font-weight: bold;">end</span>)</P><P><A NAME="src/cps/cpsbase.ml:8328"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Cont_var</span> = <span style="color: #228b22; ">Cpsvar.Make</span>(<span style="color: #0000ff; font-weight: bold;">struct</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> variable_description = <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> occurrence_description = <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> var_prefix = <span style="color: #8b2252; ">"k"</span><BR>
<span style="color: #0000ff; font-weight: bold;">end</span>)<BR></code></div></P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
