<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>union_find.ml</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -I /usr/share/texmf/tex/latex/misc ocamlweb.sty union_find.ml.tex -->
<!--CUT DEF section 1 --><!--TOC section Module Union_find-->
<H2 CLASS="section"><!--SEC ANCHOR -->Module Union_find</H2><!--SEC END --><P>
<B>1.</B> 
<A NAME="src/support/union_find.ml:0"></A><A NAME="src/support/union_find.ml:41"></A>We represent each disjoint set by a tree : elements are in the
same set than the element that they point to.</P><P>The root of the tree is the representative of the set, and
corresponds to elements of type <code>partition</code>. It points to a
"partition descriptor". 
<BR><A NAME="src/support/union_find.ml:307"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) baselink = <BR>  
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span> <span style="color: #a52a2a; ">of</span> &#X3B1; partition_descriptor<BR>  
&#X2223; <span style="color: #228b22; ">Parent</span> <span style="color: #a52a2a; ">of</span> &#X3B2;</P><P></code></div>
The partition descriptor contains the user-accessible description,
and a rank, used to optimize the union operation.</P><P>Note that the partition descriptor is not accessible by the users
of the module, and the interface make it so that there can be only
one link to the partition descriptor (from the representative).
This allows to update the partition descriptor destructively. 
<BR><A NAME="src/support/union_find.ml:825"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> &#X3B1; partition_descriptor = { <span style="color: #a020f0; ">mutable</span> rank:rank; <span style="color: #a020f0; ">mutable</span> desc:&#X3B1; }</P><P></code></div>
The rank of a partition is is a majorant of the distance of its
elements to the root (path compression makes so that the height of
the tree can be lower than the rank). The union operation minimizes
the rank, and thus the height of the tree. 
<BR><A NAME="src/support/union_find.ml:1152"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> rank = <span style="color: #228b22; ">int</span><BR></code></div><B>2.</B> 
<A NAME="src/support/union_find.ml:1172"></A>The implementation is parametrized by the safety checks that we
perform (which differs between the Fast and Safe modules). </P><P>The safe module identifies all union-find data structures by a
unique id, embed that in the links, and checks for all operation
that they are equal. It also checks initialization of the link. 
<BR><A NAME="src/support/union_find.ml:1504"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">SAFETY</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> t<BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> create: <span style="color: #228b22; ">unit</span> &#X2192; t<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link</P><P><A NAME="src/support/union_find.ml:1583"></A>  
<span style="color: #b22222">(&#X2217;  Create a safe link from a baselink.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> securize: t &#X2192; (&#X3B1;,&#X3B2;) baselink &#X2192; (&#X3B1;,&#X3B2;) link</P><P><A NAME="src/support/union_find.ml:1683"></A>  
<span style="color: #b22222">(&#X2217;  Returns the base_link from the safe link.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> get_base: (&#X3B1;,&#X3B2;) link &#X2192; (&#X3B1;,&#X3B2;) baselink</P><P><A NAME="src/support/union_find.ml:1784"></A>  
<span style="color: #b22222">(&#X2217;  Check the safe link withat the element (and the safe link) belong to t.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> check_membership: t &#X2192; (&#X3B1;,&#X3B2;) link &#X2192; <span style="color: #228b22; ">unit</span></P><P><A NAME="src/support/union_find.ml:1916"></A>  
<span style="color: #b22222">(&#X2217;  Check that the element is not yet part of any union find.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> check_unused: (&#X3B1;,&#X3B2;) link &#X2192; <span style="color: #228b22; ">unit</span></P><P><A NAME="src/support/union_find.ml:2025"></A>  
<span style="color: #b22222">(&#X2217;  Initial link.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">val</span> empty_link: (&#X3B1;,&#X3B2;) link<BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:2086"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">No_safety</span>:<span style="color: #228b22; ">SAFETY</span> = <span style="color: #0000ff; font-weight: bold;">struct</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> t = <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> create() = ()<BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link = (&#X3B1;,&#X3B2;) baselink</P><P><A NAME="src/support/union_find.ml:2196"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> securize () l = l</P><P><A NAME="src/support/union_find.ml:2222"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_membership () l = ()</P><P><A NAME="src/support/union_find.ml:2257"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_unused l = ()</P><P><A NAME="src/support/union_find.ml:2285"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> get_base l = l</P><P><A NAME="src/support/union_find.ml:2308"></A>  
<span style="color: #b22222">(&#X2217;  Note: This cast can make the execution fail without notice.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> empty_link = <span style="color: #228b22; ">Obj.</span>magic 0 <BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:2423"></A>
<span style="color: #0000ff; font-weight: bold;">type</span> unique = <span style="color: #228b22; ">int</span></P><P><A NAME="src/support/union_find.ml:2442"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Unique</span> = <span style="color: #228b22; ">Unique.Make</span>(<span style="color: #0000ff; font-weight: bold;">struct</span> <span style="color: #0000ff; font-weight: bold;">end</span>)</P><P><A NAME="src/support/union_find.ml:2483"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Safety</span>:<span style="color: #228b22; ">SAFETY</span> = <span style="color: #0000ff; font-weight: bold;">struct</span><BR>  
<span style="color: #0000ff; font-weight: bold;">type</span> t = <span style="color: #228b22; ">Unique.</span>t<BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> create() = <span style="color: #228b22; ">Unique.</span>fresh()</P><P><A NAME="src/support/union_find.ml:2567"></A>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link = t <span style="color: #228b22; ">option</span> × (&#X3B1;,&#X3B2;) baselink</P><P><A NAME="src/support/union_find.ml:2619"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> securize u l = (<span style="color: #228b22; ">Some</span> u,l)</P><P><A NAME="src/support/union_find.ml:2653"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_membership t (u,_) = <BR>    
(<span style="color: #a020f0; ">match</span> u <span style="color: #a020f0; ">with</span><BR>      
&#X2223; <span style="color: #228b22; ">Some</span>(a) &#X2192; <span style="color: #a020f0; ">assert</span> (t &#X2261; a) <span style="color: #b22222">(&#X2217;  The element is in another union-find structure.  &#X2217;)</span><BR>      
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; <span style="color: #a020f0; ">assert</span> <span style="color: #a020f0; ">false</span>); () <span style="color: #b22222">(&#X2217;  The element is in no union-find structure.  &#X2217;)</span></P><P><A NAME="src/support/union_find.ml:2882"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> check_unused (u,_) = <BR>    
(<span style="color: #a020f0; ">match</span> u <span style="color: #a020f0; ">with</span><BR>      
&#X2223; <span style="color: #228b22; ">Some</span>(_) &#X2192; <span style="color: #a020f0; ">assert</span> <span style="color: #a020f0; ">false</span> <span style="color: #b22222">(&#X2217;  The element is already in a union-find structure.  &#X2217;)</span><BR>      
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; ())</P><P><A NAME="src/support/union_find.ml:3041"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> get_base (_,l) = l</P><P><A NAME="src/support/union_find.ml:3068"></A>  
<span style="color: #b22222">(&#X2217;  Note: The cast is not dangerous, because the left-hand part is
checked first.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> empty_link = (<span style="color: #228b22; ">None</span>, <span style="color: #228b22; ">Obj.</span>magic 0) <BR>
<span style="color: #0000ff; font-weight: bold;">end</span><BR></code></div><B>3.</B> 
<A NAME="src/support/union_find.ml:3207"></A>The goal of the below "double functor" is to produce a module with
the following signature. In it, <code>partition</code> and <code>element</code> are
actually the same underlying type; the difference is that elements
returned with type <code>partition</code> are the root of the tree). Hiding
this in the interface provides some guarantee that arguments of type
partition are the representative of their partition.</P><P>Unfortunately, after calling <code>union</code> on two partitions <code>p1</code> and
<code>p2</code>, one of them will stop being the root; that is why the
partition arguments of <code>union</code> must not be re-used. Thus, defining
the <code>partition</code> type only guarantees that the argument has been a
root in the past, and we ensure that by a dynamic test. 
<BR><A NAME="src/support/union_find.ml:3929"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">S</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> t<BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> partition<BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> element<BR>      
<span style="color: #0000ff; font-weight: bold;">type</span> description<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> create: <span style="color: #228b22; ">unit</span> &#X2192; t<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> singleton : t &#X2192; element &#X2192; description &#X2192; partition<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> find : t &#X2192; element &#X2192; partition<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> union: t &#X2192; partition &#X2192; partition &#X2192; description &#X2192; partition<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> description: t &#X2192; partition &#X2192; description<BR>      
<span style="color: #0000ff; font-weight: bold;">val</span> set_description : t &#X2192; partition &#X2192; description &#X2192; <span style="color: #228b22; ">unit</span><BR>
<span style="color: #0000ff; font-weight: bold;">end</span></P><P></code></div>
This is a double functor with two arguments; <code><span style="color: #228b22; ">Saf</span></code> allows to
differenciate the "Fast" and "Safe" modules, while <code><span style="color: #228b22; ">Link</span></code> is used
to find and change the link. 
<BR><A NAME="src/support/union_find.ml:4980"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Saf</span>:<span style="color: #228b22; ">SAFETY</span>):<span style="color: #228b22; ">UNION_FIND</span> = <BR>
<span style="color: #0000ff; font-weight: bold;">struct</span></P><P><A NAME="src/support/union_find.ml:5026"></A>  
<span style="color: #0000ff; font-weight: bold;">type</span> (&#X3B1;,&#X3B2;) link = (&#X3B1;,&#X3B2;) <span style="color: #228b22; ">Saf.</span>link</P><P><A NAME="src/support/union_find.ml:5067"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> empty_link = <span style="color: #228b22; ">Saf.</span>empty_link</P><P><A NAME="src/support/union_find.ml:5104"></A>  
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #0000ff; font-weight: bold;">type</span> <span style="color: #228b22; ">LINK</span> = <span style="color: #0000ff; font-weight: bold;">sig</span><BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> element<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> description<BR>    
<span style="color: #0000ff; font-weight: bold;">val</span> get: element &#X2192; (description, element) link <BR>    
<span style="color: #0000ff; font-weight: bold;">val</span> set: element &#X2192; (description, element) link &#X2192; <span style="color: #228b22; ">unit</span><BR>  
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:5290"></A>  
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Link</span>: <span style="color: #228b22; ">LINK</span>) =<BR>  
<span style="color: #0000ff; font-weight: bold;">struct</span><BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> t = <span style="color: #228b22; ">Saf.</span>t<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> element = <span style="color: #228b22; ">Link.</span>element<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> description = <span style="color: #228b22; ">Link.</span>description<BR>    
<span style="color: #0000ff; font-weight: bold;">type</span> partition = <span style="color: #228b22; ">Link.</span>element</P><P><A NAME="src/support/union_find.ml:5453"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> create = <span style="color: #228b22; ">Saf.</span>create<BR></code></div><B>4.</B> 
<A NAME="src/support/union_find.ml:5490"></A><code>singleton</code> is the only way to add new elements to the
union-find structure, and is the place where we check that the
element is not part of another structure. 
<BR><A NAME="src/support/union_find.ml:5667"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> singleton t elt desc = <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get elt) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #228b22; ">Saf.</span>check_unused l;<BR>      
<span style="color: #228b22; ">Link.</span>set elt (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Partition_descriptor</span> {rank=0;desc=desc}));<BR>      
elt <BR></code></div><B>5.</B> 
<A NAME="src/support/union_find.ml:5856"></A>Basically, <code>find</code> just walks the tree until it finds the root.</P><P>But performance is increased if the length of the path is
diminished: traversed nodes are linked to nodes that are closer
to the roof. The possibility we have implemented is path
compression: when the root is found, the elements are changed
to link to the it, so that subsequent calls are faster. We
implemented a tail-recursive version of this algorithm (which
still requires two pass).</P><P>Note: there are alternatives to path compression, such that
halving; but in Tarjan&#X2019;s structure the root is linked to
itself, which is not the case here, so halving would require
more checks than in Tarjan&#X2019;s version. Thus we stick with path
compression. </P><P>Note: we could perform a lighter check in the safe version by
checking only the argument, and not all recursive calls; this is
probably not worth implementing it, and the heavy check has its
uses. 
<BR><A NAME="src/support/union_find.ml:6868"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> find t x = <BR>      
<span style="color: #b22222">(&#X2217;  Tail-recursive function to find the root of the algorithm.  &#X2217;)</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #0000ff; font-weight: bold;">rec</span> find x = <BR>        
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get x) <span style="color: #0000ff; font-weight: bold;">in</span><BR>        
<span style="color: #228b22; ">Saf.</span>check_membership t l;<BR>        
<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Saf.</span>get_base l <span style="color: #a020f0; ">with</span><BR>          
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span>(s) &#X2192; x<BR>          
&#X2223; <span style="color: #228b22; ">Parent</span>(y) &#X2192; find y <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #b22222">(&#X2217;  This is also tail-recursive, but we do not perform the checks
the second time. &#X2217;)</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #0000ff; font-weight: bold;">rec</span> compress x r = <BR>        
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get x) <span style="color: #0000ff; font-weight: bold;">in</span><BR>        
<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Saf.</span>get_base l <span style="color: #a020f0; ">with</span><BR>          
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span>(s) &#X2192; ()<BR>          
&#X2223; <span style="color: #228b22; ">Parent</span>(y) &#X2192; <span style="color: #228b22; ">Link.</span>set x (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> r)) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> root = find x <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
compress x root;<BR>      
root<BR></code></div><B>6.</B> 
<A NAME="src/support/union_find.ml:7541"></A>The following functions work only when the given element is
the root of a partition, but check that. 
<BR><A NAME="src/support/union_find.ml:7653"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> get_partition_descriptor t p = <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> l = (<span style="color: #228b22; ">Link.</span>get p) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #228b22; ">Saf.</span>check_membership t l;<BR>      
<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Saf.</span>get_base l <span style="color: #a020f0; ">with</span><BR>        
&#X2223; <span style="color: #228b22; ">Partition_descriptor</span>(s) &#X2192; s<BR>        
&#X2223; _ &#X2192; <span style="color: #a020f0; ">assert</span>(<span style="color: #a020f0; ">false</span>) <span style="color: #b22222">(&#X2217;  The element is not a partition.  &#X2217;)</span></P><P><A NAME="src/support/union_find.ml:7897"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> description t x = (get_partition_descriptor t x).desc</P><P><A NAME="src/support/union_find.ml:7962"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> set_description t x desc = <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> pd = get_partition_descriptor t x <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
pd.desc &#X2190; desc<BR></code></div><B>7.</B> 
<A NAME="src/support/union_find.ml:8080"></A>This function performs the union of two partitions. We use
rank to find which should be the root : we attach the smaller
tree to the root of the larger tree, so as not to increase the
maximum height (i.e. path length) of the resulting tree.</P><P>The last argument allows to update the set descriptor along
with this operation.</P><P>Note that this function takes partitions as argument; one could
have instead taken any element, and performed the find inside
the function; in particular some efficient algorithms
interleave the find and union operations. The reason why we
take partition arguments is that it avoids a find when we know
that the argument is a partition (for instance when merging
with a just-created singleton), and the user needs to perform a
find to retrieve and merge the description in the algorithms we
use (such as unification). 
<BR><A NAME="src/support/union_find.ml:9011"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
<span style="color: #0000ff; font-weight: bold;">let</span> union t p1 p2 newdesc =</P><P></code></div>      
This function also checks that p1 and p2 are partitions. 
<BR><A NAME="src/support/union_find.ml:9114"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
      
<span style="color: #0000ff; font-weight: bold;">let</span> d1 = get_partition_descriptor t p1 <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> d2 = get_partition_descriptor t p2 <span style="color: #0000ff; font-weight: bold;">in</span></P><P></code></div>      
Alternatively, the check that p1 and p2 are different could
have been done here. 
<BR><A NAME="src/support/union_find.ml:9313"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
      
<span style="color: #a020f0; ">assert</span> (p1 &#X2262; p2);<BR>      
<span style="color: #a020f0; ">if</span>( d1.rank &lt; d2.rank) <span style="color: #a020f0; ">then</span> <BR>        
<span style="color: #0000ff; font-weight: bold;">begin</span> <BR>          
<span style="color: #b22222">(&#X2217;  Keep d2_repr as root. Height of the merge is max(d1_height +1, d2_height) so does not change.  &#X2217;)</span><BR>          
<span style="color: #228b22; ">Link.</span>set p1 (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> p2));<BR>          
d2.desc &#X2190; newdesc;<BR>          
p2<BR>        
<span style="color: #0000ff; font-weight: bold;">end</span><BR>      
<span style="color: #a020f0; ">else</span> <span style="color: #a020f0; ">if</span> (d1.rank &gt; d2.rank) <span style="color: #a020f0; ">then</span><BR>        
<span style="color: #0000ff; font-weight: bold;">begin</span> <BR>          
<span style="color: #b22222">(&#X2217;  Keep d1_repr as root. Height of the merge is max(d2_height +1, d1_height) so does not change.  &#X2217;)</span><BR>          
<span style="color: #228b22; ">Link.</span>set p2 (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> p1));<BR>          
d1.desc &#X2190; newdesc;<BR>          
p1<BR>        
<span style="color: #0000ff; font-weight: bold;">end</span><BR>      
<span style="color: #a020f0; ">else</span> <BR>        
<span style="color: #0000ff; font-weight: bold;">begin</span><BR>          
<span style="color: #b22222">(&#X2217;  We choose arbitrarily p1 to be the root. 
	 The height may have changed, as all elements in the subset
	 with root p2 are 1 step further to the root.  &#X2217;)</span><BR>          
<span style="color: #228b22; ">Link.</span>set p2 (<span style="color: #228b22; ">Saf.</span>securize t (<span style="color: #228b22; ">Parent</span> p1));<BR>          
d1.rank &#X2190; d1.rank + 1; d1.desc &#X2190; newdesc;<BR>          
p1<BR>        
<span style="color: #0000ff; font-weight: bold;">end</span><BR>  
<span style="color: #0000ff; font-weight: bold;">end</span></P><P><A NAME="src/support/union_find.ml:10180"></A>
<span style="color: #0000ff; font-weight: bold;">end</span><BR></code></div><B>8.</B> 
<A NAME="src/support/union_find.ml:10189"></A>The double-functor is not shown in the exposed interface, and we
only export the following, simpler modules. 
<BR><A NAME="src/support/union_find.ml:10305"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Fast</span>=<span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">No_safety</span>)</P><P><A NAME="src/support/union_find.ml:10335"></A>
<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">Safe</span>=<span style="color: #228b22; ">Make</span>(<span style="color: #228b22; ">Safety</span>)<BR></code></div><B>9.</B> 
<A NAME="src/support/union_find.ml:10365"></A>For a survey of the implementations of union-find algorithms, one
should read "Worst-Case Analysis of Set Union Algorithms", by
Tarjan and Van Leeuwen.</P><P>Recent performance comparison of these algorithms (and modern
enhancements) can be found in "Experiments on Union-Find Algorithms
for the Disjoint-Set Data Structure", by Md. Mostofa Ali Patwary,
Jean Blair, Fredrik Manne. 
<BR></P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
