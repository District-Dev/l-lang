<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>cpsllvm.ml</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -I /usr/share/texmf/tex/latex/misc ocamlweb.sty cpsllvm.ml.tex -->
<!--CUT DEF section 1 --><!--TOC section Module Cpsllvm-->
<H2 CLASS="section"><!--SEC ANCHOR -->Module Cpsllvm</H2><!--SEC END --><P>
<B>1.</B> 
<A NAME="src/llvm/cpsllvm.ml:0"></A><A NAME="src/llvm/cpsllvm.ml:76"></A>This module translates a term written in CPS representation to
LLVM instructions in SSA form.</P><P>The CPS representations stems from the paper "Compiling with
continuations, continued" by Andrew Kennedy. In particular this
representation separates continuations from standard lambda
functions, which allows calling and returning from functions using
the normal stack.</P><P>This module assumes that functions have no free variables (or
continuation variables). Closure conversion removes free variables
from functions. Free continuation variables should never happen
when translating normal terms to CPS.</P><P>The module also assumes that the CPS values do not refer to
primitive operations, such as +,-,*,/. Previous passes must
transform calls to primitive operations to <I>let</I> <I>x</I> =
<I>primitive</I>(<I>args</I>); and &#X3B7;-expand primitive operations passed as
functions (e.g. <I>let</I> <I>x</I> = <I>f</I>() must have been transformed).</P><P>To keep things simple in this first version, no external functions
is called (only lambdas defined in the body of the expression, and
primitive operations, can be called). </P><P>In addition, all data is boxed, allocated using malloc (and never
freed; this could be improved by using libgc). Unboxed data would
requires to carry typing information in the CPS terms. 
<BR><B>2.</B> 
<A NAME="src/llvm/cpsllvm.ml:1386"></A>To get an overview of the translation algorithm, the best is to
understand how the CPS concepts are mapped to the SSA concepts. In
the following, we denote by [<I>x</I>] the translation of <I>x</I>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">Lambda are translated to LLVM functions with one argument and
one return value.</LI><LI CLASS="li-itemize">Other values (i.e. int, floats, and tuples) are all translated
boxed. Thus they all have a single llvm type, which is i8 *.</LI><LI CLASS="li-itemize">A CPS variable <I>x</I> is mapped to a SSA variables (of type
<code><span style="color: #228b22; ">Llvm</span>.llvalue</code>). CPS variables are introduced as arguments to lambda
and continuations, and in the <I>let</I> <I>x</I> = ...  form.</LI><LI CLASS="li-itemize">A CPS continuation variable <I>k</I> introduced by &#X3BB; <I>k</I>. <I>x</I>. <I>t</I>
corresponds to the return from the lambda. A call <I>k</I>(<I>y</I>) to this
continuation with a value <I>y</I> is translated to a "ret" instruction
returning the translation of <I>y</I>.</LI><LI CLASS="li-itemize">A CPS continuation variable <I>k</I> introduced by <I>let</I> <I>k</I>(<I>x</I>) = <I>t</I><SUB>1</SUB>;
<I>t</I><SUB>2</SUB> is mapped to the SSA basic block [<I>t</I>1] (of type
<code><span style="color: #228b22; ">Llvm</span>.basicblock</code>). The <I>x</I> formal argument of <I>k</I> corresponds to a
phi node at the start of [<I>t</I>1]. A call <I>k</I>( <I>y</I> to this continuation
with a value <I>y</I> is translated to a "jmp" instruction to the basic
block [<I>t</I>1], that binds [<I>y</I>] to the phi node at the start of
<code>[t1]</code>.</LI><LI CLASS="li-itemize">A call <I>f</I>( <I>k</I>, <I>x</I>) of a regular (non-continuation) function <I>f</I>
with first argument being a continuation variable argument <I>k</I> and
second argument being a variable <I>v</I> is translated to a call to
[<I>f</I>] with argument [<I>x</I>], followed by the translation of <I>k</I>( <I>r</I>),
with <I>r</I> being the value returned by the call to <I>f</I>. This is because
after calling a function in the LLVM SA, the control is returned to
the following instruction. LLVM optimization passes like simplifycfg
can optimize this if needed. Note: this allows tail call
optimizations
<A HREF="http://llvm.org/docs/CodeGenerator.html#tail-calls"><TT>http://llvm.org/docs/CodeGenerator.html#tail-calls</TT></A> to take
place.</LI><LI CLASS="li-itemize">Primitive operations, such as <I>let</I> <I>x</I> = <I>primitive</I>(<I>args</I>)
are translated to the corresponding LLVM operations.</LI></UL><P>Note that the SSA representation are well-formed only if "the
definition of a variable <CODE>%x</CODE> does not dominate all of its uses"
(<A HREF="http://llvm.org/docs/LangRef.html#introduction"><TT>http://llvm.org/docs/LangRef.html#introduction</TT></A>). The translation
from a CPS term (without free variables) ensures that. 
<BR><B>3.</B> 
<A NAME="src/llvm/cpsllvm.ml:3726"></A>Here is a simplified example of how the translation from CPS to
SSA works.</P><P>The CPS code:
</P><PRE CLASS="verbatim">  let v = 3;
  let k(x) = k(2+x);
  k(11)  </PRE><P>Is translated to SSA (ignoring boxing):
</P><PRE CLASS="verbatim">  entry: 
    v = 3
    n_ = 11
    jmp k

  k:
    x = phi (entry n_) (k o_)
    m_ = 2 
    o_ = m_ + x
    jmp k </PRE><P>This shows how <I>k</I> is translated to a separate basic block, and the
argument <I>x</I> to a phi node connected to all the uses of <I>k</I>.</P><P><BR><B>4.</B> 
<A NAME="src/llvm/cpsllvm.ml:4234"></A>If one encounters segmentation faults when changing the LLVM
related code, this may be caused by:</P><UL CLASS="itemize"><LI CLASS="li-itemize">Calling <code><span style="color: #228b22; ">Llvm</span>.build_call</code> on a value which does not have the
function <code>lltype</code>, or <code><span style="color: #228b22; ">Llvm</span>.build_gep</code> with operations that do not
correspond to the lltype of the value.</LI><LI CLASS="li-itemize">Calling <code>build_phi</code> with an empty list of "incoming".</LI><LI CLASS="li-itemize">Calling <code><span style="color: #228b22; ">ExecutionEngine</span>.create the_module</code> before calling
<code><span style="color: #228b22; ">Llvm_executionengine</span>.initialize_native_target()</code> can also segfault.</LI></UL><P>Using valgrind or gdb allows to quickly locate the problematic Ocaml
Llvm binding.</P><P><BR><A NAME="src/llvm/cpsllvm.ml:4849"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> context = <span style="color: #228b22; ">Llvm.</span>global_context()</P><P><A NAME="src/llvm/cpsllvm.ml:4887"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> the_module = <span style="color: #228b22; ">Llvm.</span>create_module context <span style="color: #8b2252; ">"my jitted module"</span></P><P><A NAME="src/llvm/cpsllvm.ml:4953"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> void_type = <span style="color: #228b22; ">Llvm.</span>void_type context</P><P><A NAME="src/llvm/cpsllvm.ml:4994"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> i32_type = <span style="color: #228b22; ">Llvm.</span>i32_type context</P><P><A NAME="src/llvm/cpsllvm.ml:5033"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> i32star_type = <span style="color: #228b22; ">Llvm.</span>pointer_type i32_type</P><P><A NAME="src/llvm/cpsllvm.ml:5081"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> anystar_type = <span style="color: #228b22; ">Llvm.</span>pointer_type (<span style="color: #228b22; ">Llvm.</span>i8_type context)</P><P><A NAME="src/llvm/cpsllvm.ml:5144"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> undef_anystar = <span style="color: #228b22; ">Llvm.</span>undef anystar_type</P><P><A NAME="src/llvm/cpsllvm.ml:5190"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> null_anystar = <span style="color: #228b22; ">Llvm.</span>const_null anystar_type</P><P><A NAME="src/llvm/cpsllvm.ml:5241"></A>
<span style="color: #0000ff; font-weight: bold;">open</span> <span style="color: #228b22; ">Cpsbase</span></P><P></code></div>
</P><!--TOC subsection Creating and accessing memory objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Creating and accessing memory objects</H3><!--SEC END --><P> 
<BR><B>5.</B> 
<A NAME="src/llvm/cpsllvm.ml:5319"></A>These helper functions create or read-from memory object.
Currently LLVM compiles using a very simple strategy: every value is
boxed (including integers and floats). This simplifies compilation a
lot: every value we create has type void *, and we cast the type
from void * according to how we use it.</P><P>LLVM does not (yet?) know how to replace heap allocations with stack
allocations, so we should do that (using an escape analysis). But
LLVM has passes that allow promotion of stack allocations to
register ("mem2reg" and "scalarrepl"), so once this is done (plus
passing and returning arguments in registers), many values should be
unboxed by the compiler (and this would not be that inefficient).
Additional performances could then be obtained by monomorphizing the
code. 
<BR><B>6.</B> 
<A NAME="src/llvm/cpsllvm.ml:6125"></A>Store <code>llvalue</code> in heap-allocated memory. 
<BR><A NAME="src/llvm/cpsllvm.ml:6172"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_box llvalue name builder = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> lltype = <span style="color: #228b22; ">Llvm.</span>type_of llvalue <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> pointer = <span style="color: #228b22; ">Llvm.</span>build_malloc lltype name builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
ignore(<span style="color: #228b22; ">Llvm.</span>build_store llvalue pointer builder);<BR>  
<span style="color: #228b22; ">Llvm.</span>build_bitcast pointer anystar_type (name ^ <span style="color: #8b2252; ">"box"</span>) builder<BR></code></div><B>7.</B> 
<A NAME="src/llvm/cpsllvm.ml:6428"></A>Unbox a <code>llvalue</code> of type <code>lltype</code>. 
<BR><A NAME="src/llvm/cpsllvm.ml:6470"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_unbox llvalue lltype name builder = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> typeptr = <span style="color: #228b22; ">Llvm.</span>pointer_type lltype <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> castedptr = <span style="color: #228b22; ">Llvm.</span>build_bitcast llvalue typeptr (name ^ <span style="color: #8b2252; ">"castedptr"</span>) builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #228b22; ">Llvm.</span>build_load castedptr (name ^ <span style="color: #8b2252; ">"unbox"</span>) builder<BR></code></div><B>8.</B> 
<A NAME="src/llvm/cpsllvm.ml:6706"></A>A n-tuple is allocated as an array of n <code>anystar_type</code>. Each
element of the array contains the llvalue in l. 
<BR><A NAME="src/llvm/cpsllvm.ml:6823"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_tuple l builder = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> length = <span style="color: #228b22; ">List.</span>length l <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> array_type = <span style="color: #228b22; ">Llvm.</span>array_type anystar_type length <span style="color: #0000ff; font-weight: bold;">in</span> <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> pointer = <span style="color: #228b22; ">Llvm.</span>build_malloc array_type <span style="color: #8b2252; ">"tuple"</span> builder <span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:7008"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> f () (<span style="color: #228b22; ">int</span>,elem) = <BR>    
<span style="color: #b22222">(&#X2217;  Note: the first 0 is because pointer is not the start of
the array, but a pointer to the start of the array, that
must thus be dereferenced.  &#X2217;)</span><BR>    
<span style="color: #0000ff; font-weight: bold;">let</span> path = [| (<span style="color: #228b22; ">Llvm.</span>const_int i32_type 0); (<span style="color: #228b22; ">Llvm.</span>const_int i32_type <span style="color: #228b22; ">int</span>) |] <span style="color: #0000ff; font-weight: bold;">in</span><BR>    
<span style="color: #0000ff; font-weight: bold;">let</span> gep_ptr = <span style="color: #228b22; ">Llvm.</span>build_gep pointer path <span style="color: #8b2252; ">"gep"</span> builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>    
ignore(<span style="color: #228b22; ">Llvm.</span>build_store elem gep_ptr builder) <span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:7398"></A>  
<span style="color: #228b22; ">Utils.Int.</span>fold_with_list f () (0,l);<BR>  
<span style="color: #228b22; ">Llvm.</span>build_bitcast pointer anystar_type (<span style="color: #8b2252; ">"tuplecast"</span>) builder<BR></code></div><B>9.</B> 
<A NAME="src/llvm/cpsllvm.ml:7506"></A>Retrieve an element from a tuple. 
<BR><A NAME="src/llvm/cpsllvm.ml:7546"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_letproj pointer i builder = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> stringi = (string_of_int i) <span style="color: #0000ff; font-weight: bold;">in</span> <BR>  
<span style="color: #b22222">(&#X2217;  First we compute an acceptable LLvm type, and cast the pointer to
that type (failure to do that makes <code><span style="color: #228b22; ">Llvm</span>.build_gep</code> segfault).
As we try to access the ith element, we assume we are accessing
an array of size i+1.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> array_type = <span style="color: #228b22; ">Llvm.</span>array_type anystar_type (i+1) <span style="color: #0000ff; font-weight: bold;">in</span> <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> arraystar_type = <span style="color: #228b22; ">Llvm.</span>pointer_type array_type <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> cast_pointer = <span style="color: #228b22; ">Llvm.</span>build_bitcast pointer arraystar_type (<span style="color: #8b2252; ">"castptr"</span>) builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> gep_ptr = <span style="color: #228b22; ">Llvm.</span>build_gep cast_pointer [| (<span style="color: #228b22; ">Llvm.</span>const_int i32_type 0);<BR>                                                
(<span style="color: #228b22; ">Llvm.</span>const_int i32_type i) |] <BR>    
(<span style="color: #8b2252; ">"gep"</span> ^ stringi) builder <span style="color: #0000ff; font-weight: bold;">in</span> <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> result = <span style="color: #228b22; ">Llvm.</span>build_load gep_ptr (<span style="color: #8b2252; ">"builder"</span> ^ stringi) builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
result <BR></code></div><B>10.</B> 
<A NAME="src/llvm/cpsllvm.ml:8337"></A>Apply primitive operations. 
<BR><A NAME="src/llvm/cpsllvm.ml:8371"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_integer_binary_op op a b builder = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> build_fn = <span style="color: #a020f0; ">match</span> op <span style="color: #a020f0; ">with</span><BR>    
&#X2223; <span style="color: #228b22; ">Constant.IAdd</span> &#X2192; <span style="color: #228b22; ">Llvm.</span>build_add<BR>    
&#X2223; <span style="color: #228b22; ">Constant.ISub</span> &#X2192; <span style="color: #228b22; ">Llvm.</span>build_sub<BR>    
&#X2223; <span style="color: #228b22; ">Constant.IMul</span> &#X2192; <span style="color: #228b22; ">Llvm.</span>build_mul<BR>    
&#X2223; <span style="color: #228b22; ">Constant.IDiv</span> &#X2192; <span style="color: #228b22; ">Llvm.</span>build_udiv <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> a_unbox = (build_unbox a i32_type <span style="color: #8b2252; ">"a"</span> builder) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> b_unbox = (build_unbox b i32_type <span style="color: #8b2252; ">"b"</span> builder) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> res = build_fn a_unbox b_unbox <span style="color: #8b2252; ">"bop"</span> builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
build_box res <span style="color: #8b2252; ">"res"</span> builder<BR></code></div><B>11.</B> 
<A NAME="src/llvm/cpsllvm.ml:8809"></A>Build a call instruction, casting <code>caller</code> to a function pointer. 
<BR><A NAME="src/llvm/cpsllvm.ml:8880"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_call caller callee builder =<BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> function_type = <span style="color: #228b22; ">Llvm.</span>pointer_type (<span style="color: #228b22; ">Llvm.</span>function_type anystar_type [| anystar_type |]) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> casted_caller = <span style="color: #228b22; ">Llvm.</span>build_bitcast caller function_type <span style="color: #8b2252; ">"function"</span> builder <span style="color: #0000ff; font-weight: bold;">in</span> <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> retval = <span style="color: #228b22; ">Llvm.</span>build_call casted_caller [| callee |] <span style="color: #8b2252; ">"retval"</span> builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
retval</P><P></code></div>
</P><!--TOC subsection Creating and accessing basic blocks-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Creating and accessing basic blocks</H3><!--SEC END --><P> 
<BR><B>12.</B> 
<A NAME="src/llvm/cpsllvm.ml:9250"></A>This special value is used to ensure, via the type checker, that
compilation to LLVM never leaves a basic-block halfly built. LLVM
basic blocks should all end with a terminator instruction; whenever
one is inserted, the function should return <code><span style="color: #228b22; ">End_of_block</span></code>. When
building non-terminator instructions, the code must continue
building the basic block. 
<BR><A NAME="src/llvm/cpsllvm.ml:9621"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">type</span> termination = <span style="color: #228b22; ">End_of_block</span><BR></code></div><B>13.</B> 
<A NAME="src/llvm/cpsllvm.ml:9658"></A>This creates a new basic block in the current function.</P><P>Note that LLVM basic blocks are associated to a parent function,
that we need to retrieve to create a new basic block. 
<BR><A NAME="src/llvm/cpsllvm.ml:9845"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> new_block builder = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> current_bb = <span style="color: #228b22; ">Llvm.</span>insertion_block builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> the_function = <span style="color: #228b22; ">Llvm.</span>block_parent current_bb <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> new_bb = <span style="color: #228b22; ">Llvm.</span>append_block context <span style="color: #8b2252; ">"k"</span> the_function <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
new_bb<BR></code></div><B>14.</B> 
<A NAME="src/llvm/cpsllvm.ml:10049"></A>Returns <code><span style="color: #228b22; ">Some</span>(phi)</code> if the block already begins with a phi instruction,
or <code><span style="color: #228b22; ">None</span></code> otherwise. 
<BR><A NAME="src/llvm/cpsllvm.ml:10150"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> begin_with_phi_node basic_block = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> pos = <span style="color: #228b22; ">Llvm.</span>instr_begin basic_block <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #a020f0; ">match</span> pos <span style="color: #a020f0; ">with</span><BR>    
&#X2223; <span style="color: #228b22; ">Llvm.At_end</span>(_) &#X2192; <span style="color: #228b22; ">None</span><BR>    
&#X2223; <span style="color: #228b22; ">Llvm.Before</span>(inst) &#X2192; <BR>      
(<span style="color: #a020f0; ">match</span> <span style="color: #228b22; ">Llvm.</span>instr_opcode inst <span style="color: #a020f0; ">with</span><BR>        
&#X2223; <span style="color: #228b22; ">Llvm.Opcode.PHI</span> &#X2192; <span style="color: #228b22; ">Some</span>(inst)<BR>        
&#X2223; _ &#X2192; <span style="color: #228b22; ">None</span>)<BR></code></div><B>15.</B> 
<A NAME="src/llvm/cpsllvm.ml:10556"></A>This builds a jmp instruction to <code>destination_block</code>, also passing
the <code>v</code> value. This is achieved by setting <code>v</code> as an incoming value
for the phi instruction that begins <code>destination_block</code>. If
<code>destination_block</code> does not start with a phi node, then it is the
first time that <code>destination_block</code> is called, and we create this
phi node. 
<BR><A NAME="src/llvm/cpsllvm.ml:10914"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_jmp_to_and_add_incoming destination_block v builder =</P><P><A NAME="src/llvm/cpsllvm.ml:10979"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> add_incoming_to_block basic_block (value,curblock) = <BR>    
<span style="color: #a020f0; ">match</span> begin_with_phi_node basic_block <span style="color: #a020f0; ">with</span><BR>      
&#X2223; <span style="color: #228b22; ">Some</span>(phi) &#X2192; <span style="color: #228b22; ">Llvm.</span>add_incoming (value,curblock) phi<BR>      
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; <BR>        
<span style="color: #b22222">(&#X2217;  Temporarily create a builder to build the phi instruction.  &#X2217;)</span><BR>        
<span style="color: #0000ff; font-weight: bold;">let</span> builder = <span style="color: #228b22; ">Llvm.</span>builder_at context (<span style="color: #228b22; ">Llvm.</span>instr_begin basic_block) <span style="color: #0000ff; font-weight: bold;">in</span><BR>        
ignore(<span style="color: #228b22; ">Llvm.</span>build_phi [value,curblock] <span style="color: #8b2252; ">"phi"</span> builder) <span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:11382"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> current_basic_block = <span style="color: #228b22; ">Llvm.</span>insertion_block builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
add_incoming_to_block destination_block (v, current_basic_block);</P><P><A NAME="src/llvm/cpsllvm.ml:11511"></A>  
ignore(<span style="color: #228b22; ">Llvm.</span>build_br destination_block builder);<BR>  
<span style="color: #228b22; ">End_of_block</span><BR></code></div><B>16.</B> 
<A NAME="src/llvm/cpsllvm.ml:11583"></A>We use the following sum type to establish a distinction between:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">continuation variables bound with lambda: calling them
returns from the function, and the parameter <code>x</code> of the call <code>k( x)</code>
is returned;</LI><LI CLASS="li-itemize">and continuation variables bound with letcont: calling them
jumps to the corresponding basic block, and the parameter <code>x</code> of
the call <code>k( x)</code> is passed to the phi node starting this basic
block.</LI></UL><P> 
The CPS&#X2192;LLVM translation maps continuation variables to <code>dest_type</code>s.</P><P><BR><A NAME="src/llvm/cpsllvm.ml:12137"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">type</span> dest_type = <BR>  
&#X2223; <span style="color: #228b22; ">Ret</span> <BR>  
&#X2223; <span style="color: #228b22; ">Jmp_to</span> <span style="color: #a52a2a; ">of</span> <span style="color: #228b22; ">Llvm.</span>llbasicblock</P><P></code></div>
Build a call to a continuation <code>k x</code>. 
<BR><A NAME="src/llvm/cpsllvm.ml:12242"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> build_applycont k x builder = <BR>  
<span style="color: #a020f0; ">match</span> k <span style="color: #a020f0; ">with</span><BR>    
&#X2223; <span style="color: #228b22; ">Ret</span> &#X2192; ignore(<span style="color: #228b22; ">Llvm.</span>build_ret x builder); <span style="color: #228b22; ">End_of_block</span><BR>    
&#X2223; <span style="color: #228b22; ">Jmp_to</span>(destination) &#X2192; build_jmp_to_and_add_incoming destination x builder</P><P></code></div>
</P><!--TOC subsection Main CPS term translation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Main CPS term translation</H3><!--SEC END --><P> 
<BR>
It is important for LLVM that function names are unique. 
<BR><A NAME="src/llvm/cpsllvm.ml:12546"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">module</span> <span style="color: #228b22; ">UniqueFunctionId</span> = <span style="color: #228b22; ">Unique.Make</span>(<span style="color: #0000ff; font-weight: bold;">struct</span> <span style="color: #0000ff; font-weight: bold;">end</span>)<BR></code></div><B>17.</B> 
<A NAME="src/llvm/cpsllvm.ml:12601"></A>This function builds the CPS term <code>cps</code>, in the current block
pointed to by <code>builder</code>. <code>varmap</code> maps CPS variables to LLVM
llvalues. <code>contvarmap</code> maps CPS continuation variables to values of
type <code>contvar_type</code>.</P><P>All the free variables or continuation variables in <code>cps</code> must be
in <code>contvarmap</code> or in <code>varmap</code>. <code>cps</code> can contain lambda, but they
must not contain any free variables or free continuation variables
(even the one in <code>varmap</code> and <code>contvarmap</code>). Closure conversion
deals with this. Note: previously-defined global variables are not
considered free. 
<BR><A NAME="src/llvm/cpsllvm.ml:13185"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #0000ff; font-weight: bold;">rec</span> build_term cps (contvarmap, varmap) builder =<BR></code></div><B>18.</B> 
<A NAME="src/llvm/cpsllvm.ml:13245"></A>Helper functions to retrieve/add values from/to maps. 
<BR><A NAME="src/llvm/cpsllvm.ml:13305"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
  
<span style="color: #0000ff; font-weight: bold;">let</span> lookup_free_var x = <BR>    
<span style="color: #b22222">(&#X2217;  XXX: Now more than that. Depending on the binding site, we
return different results. For now we differenciate only
globals, but constants should also have a special treatment.</P><P> &#X2217;)</span><BR>    
<span style="color: #0000ff; font-weight: bold;">let</span> bound_var = <span style="color: #228b22; ">Cpsbase.Var.Occur.</span>binding_variable x <span style="color: #0000ff; font-weight: bold;">in</span><BR>    
<span style="color: #0000ff; font-weight: bold;">let</span> llvalue = <BR>      
<span style="color: #a020f0; ">try</span> <span style="color: #228b22; ">Cpsbase.Var.Var.Map.</span>find bound_var varmap<BR>      
<span style="color: #a020f0; ">with</span> _ &#X2192; <span style="color: #a020f0; ">failwith</span> <span style="color: #8b2252; ">"in lookup_var"</span> <span style="color: #0000ff; font-weight: bold;">in</span><BR>    
<span style="color: #0000ff; font-weight: bold;">let</span> bound_var_desc = (<span style="color: #228b22; ">Cpsbase.Var.Var.</span>description bound_var) <span style="color: #0000ff; font-weight: bold;">in</span><BR>    
<span style="color: #a020f0; ">match</span> bound_var_desc.Cpsbase.binding_site_var <span style="color: #a020f0; ">with</span><BR>      
<span style="color: #b22222">(&#X2217;  Global dynamic values are allocated with an extra level of
indirection.  &#X2217;)</span><BR>      
&#X2223; <span style="color: #228b22; ">Cpsbase.Enclosing_definition</span>(_,<span style="color: #228b22; ">Dynamic_value</span>(_)) &#X2192; <BR>        
build_unbox llvalue anystar_type <span style="color: #8b2252; ">"loadglob"</span> builder<BR>      
<span style="color: #b22222">(&#X2217;  XXX: We could simplify the compilation of integer constants
here: inserting constant values instead of the corresponding
variable. Not worth it: llvm will deal with that. &#X2217;)</span><BR>      
&#X2223; _ &#X2192; llvalue<BR>  
<span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:14284"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> lookup_contvar k = <BR>    
<span style="color: #a020f0; ">try</span> <span style="color: #228b22; ">Cpsbase.Cont_var.Var.Map.</span>find (<span style="color: #228b22; ">Cpsbase.Cont_var.Occur.</span>binding_variable k) contvarmap <BR>    
<span style="color: #a020f0; ">with</span> _ &#X2192; <span style="color: #a020f0; ">failwith</span> <span style="color: #8b2252; ">"in lookup_contvar"</span> <span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:14451"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> add_to_varmap var value = <span style="color: #228b22; ">Cpsbase.Var.Var.Map.</span>add var value varmap <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> add_to_contvarmap contvar block = <span style="color: #228b22; ">Cpsbase.Cont_var.Var.Map.</span>add contvar (<span style="color: #228b22; ">Jmp_to</span> block) contvarmap <span style="color: #0000ff; font-weight: bold;">in</span><BR></code></div><B>19.</B> 
<A NAME="src/llvm/cpsllvm.ml:14638"></A>Converting the term is done by inductive decomposition. There are
three kind of cases: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
those that only build new values (letvalue, letproj,
letprimop...) in the current basic block
</LI><LI CLASS="li-itemize">those that return a value and end a basic block 
(apply, applycont, and halt)
</LI><LI CLASS="li-itemize">the one that build a new basic blocks (letcont).
</LI></UL><P>To keep the implementation simple, all values are boxed (i.e. put
in the heap and accessed through a pointer), and of llvm type "i8
*". Pointer conversions are done according to the use of the
value. 
<BR><A NAME="src/llvm/cpsllvm.ml:15249"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
  
<span style="color: #a020f0; ">match</span> cps.Cpsbase.term <span style="color: #a020f0; ">with</span><BR></code></div><B>20.</B> 
<A NAME="src/llvm/cpsllvm.ml:15287"></A>These cases build a new value, then continue building the
basic block. 
<BR><A NAME="src/llvm/cpsllvm.ml:15369"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
&#X2223; <span style="color: #228b22; ">Let_prim</span>(x, <span style="color: #228b22; ">Value</span> value, body) &#X2192; <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> newllvalue = <BR>        
(<span style="color: #a020f0; ">match</span> value <span style="color: #a020f0; ">with</span> <BR>          
&#X2223; <span style="color: #228b22; ">Constant</span>(<span style="color: #228b22; ">Constant.Int</span> i) &#X2192;<BR>            
<span style="color: #0000ff; font-weight: bold;">let</span> llvalue = <span style="color: #228b22; ">Llvm.</span>const_int i32_type i <span style="color: #0000ff; font-weight: bold;">in</span><BR>            
build_box llvalue (<span style="color: #8b2252; ">"int"</span> ^ string_of_int i) builder</P><P></code></div>          
Any value is a pointer, including void; so we compile
void to (void * ) 0. 
<BR><A NAME="src/llvm/cpsllvm.ml:15725"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
          
&#X2223; <span style="color: #228b22; ">Constant</span>(<span style="color: #228b22; ">Constant.Void</span>) &#X2192;<BR>            
<span style="color: #0000ff; font-weight: bold;">let</span> zero = <span style="color: #228b22; ">Llvm.</span>const_int i32_type 0 <span style="color: #0000ff; font-weight: bold;">in</span><BR>            
<span style="color: #228b22; ">Llvm.</span>const_pointercast zero anystar_type</P><P><A NAME="src/llvm/cpsllvm.ml:15885"></A>          
&#X2223; <span style="color: #228b22; ">Tuple</span>(l) &#X2192;<BR>            
<span style="color: #0000ff; font-weight: bold;">let</span> llvalues = <span style="color: #228b22; ">List.</span>map lookup_free_var l <span style="color: #0000ff; font-weight: bold;">in</span><BR>            
build_tuple llvalues builder</P><P></code></div>          
This build a new function, with private linkage (since
that it can be used only by the current term), which
allows llvm optimizations.</P><P>Note that <code>build_function</code> will use a new builder, so the
lambda can be built in parallel with the current
function. Also it will use new variables and continuation
variable maps (with only the x parameter), so the lambda
expression must not contain any free variables. 
<BR><A NAME="src/llvm/cpsllvm.ml:16521"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
          
&#X2223; <span style="color: #228b22; ">Lambda</span>(k,x,body) &#X2192; <BR>            
<span style="color: #0000ff; font-weight: bold;">let</span> f = build_function <span style="color: #8b2252; ">"lambda"</span> k x body <span style="color: #0000ff; font-weight: bold;">in</span><BR>            
<span style="color: #228b22; ">Llvm.</span>set_linkage <span style="color: #228b22; ">Llvm.Linkage.Private</span> f;<BR>            
<span style="color: #228b22; ">Llvm.</span>build_bitcast f anystar_type <span style="color: #8b2252; ">"lambdacast"</span> builder</P><P></code></div>          
Expressions such as <I>let</I> <I>x</I> = <I>primitive</I> should have
been translated into something like <I>let</I> <I>x</I> =  (<I>a</I>,<I>b</I>) &#X2212;&gt;
<I>primitiveop</I>( <I>a</I>,<I>b</I>)  in previous compilation stage, so
should fail here. 
<BR><A NAME="src/llvm/cpsllvm.ml:16975"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
          
&#X2223; <span style="color: #228b22; ">Constant</span>(c) &#X2192; print_endline (<span style="color: #228b22; ">Constant.</span>to_string c);<BR>            
<span style="color: #a020f0; ">assert</span>( <span style="color: #228b22; ">Constant.</span>is_function c);<BR>            
<span style="color: #a020f0; ">failwith</span> <span style="color: #8b2252; ">"ICE: primitive operations as value in LLVM translation."</span><BR>        
)<BR>      
<span style="color: #0000ff; font-weight: bold;">in</span> build_term body (contvarmap, (add_to_varmap x newllvalue)) builder</P><P></code></div>    
Primitive operations are similar to letvalue. 
<BR><A NAME="src/llvm/cpsllvm.ml:17308"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
&#X2223; <span style="color: #228b22; ">Let_prim</span>(x,prim,body) &#X2192; <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> result = (<span style="color: #a020f0; ">match</span> prim <span style="color: #a020f0; ">with</span> <BR>        
&#X2223; <span style="color: #228b22; ">Integer_binary_op</span>(op,xa,xb) &#X2192; <BR>          
build_integer_binary_op op (lookup_free_var xa) (lookup_free_var xb) builder<BR>        
&#X2223; <span style="color: #228b22; ">Projection</span>(x,i) &#X2192; build_letproj (lookup_free_var x) i builder<BR>      
) <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
build_term body (contvarmap, (add_to_varmap x result)) builder<BR></code></div><B>21.</B> 
<A NAME="src/llvm/cpsllvm.ml:17918"></A>Building new basic blocks. The algorithm first creates an
empty basic block, bound to <code>k</code>, then build <code>body</code>, then build
<code>term</code> (if <code>k</code> is really called), binding <code>x</code> to the phi node.</P><P>The tricky part is that the llvm bindings do not allow to create
an "empty" phi node (even if it would, in future implementations
which would not box everything we would still have to know the
llvm type of the phi node, and that llvm type is not known until
we have processed the jumps to that node). So it is the calls to
k that create or change the phi node; no phi node means <code>k</code> is
never called.</P><P>Doing the operations in this order ensures that calls to <code>k</code> are
processed before <code>k</code> is built. 
<BR><A NAME="src/llvm/cpsllvm.ml:18671"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
&#X2223; <span style="color: #228b22; ">Let_cont</span>(k,x,term,body) &#X2192; <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> new_bb = new_block builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> newcvm = add_to_contvarmap k new_bb <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #228b22; ">End_of_block</span> = build_term body (newcvm, varmap) builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
<span style="color: #228b22; ">Llvm.</span>position_at_end new_bb builder;<BR>      
(<span style="color: #a020f0; ">match</span> begin_with_phi_node new_bb <span style="color: #a020f0; ">with</span><BR>        
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; <span style="color: #228b22; ">End_of_block</span><BR>        
&#X2223; <span style="color: #228b22; ">Some</span>(phi) &#X2192; build_term term (newcvm, (add_to_varmap x phi)) builder)<BR></code></div><B>22.</B> 
<A NAME="src/llvm/cpsllvm.ml:19069"></A>Cases that change or create basic blocks. 
<BR>    
Depending on k, applycont either returns or jumps to k. 
<BR><A NAME="src/llvm/cpsllvm.ml:19183"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
&#X2223; <span style="color: #228b22; ">Apply_cont</span>(k,x) &#X2192; <BR>      
build_applycont (lookup_contvar k) (lookup_free_var x) builder</P><P></code></div>    
The CPS semantics state that caller should return to k, but
LLVM SSA does not require that calls end basic blocks. So we
just build a call instruction, and then a call to <code>k</code>. LLVM
optimizations will eliminate the superfluous jump if needed. 
<BR><A NAME="src/llvm/cpsllvm.ml:19552"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
&#X2223; <span style="color: #228b22; ">Apply</span>(caller,k,callee) &#X2192; <BR>      
<span style="color: #0000ff; font-weight: bold;">let</span> retval = build_call (lookup_free_var caller) (lookup_free_var callee) builder <span style="color: #0000ff; font-weight: bold;">in</span><BR>      
build_applycont (lookup_contvar k) retval builder</P><P><A NAME="src/llvm/cpsllvm.ml:19733"></A>    
&#X2223; <span style="color: #228b22; ">Halt</span>(x) &#X2192; ignore(<span style="color: #228b22; ">Llvm.</span>build_ret (lookup_free_var x) builder); <span style="color: #228b22; ">End_of_block</span></P><P></code></div>
Expression built out of a definition are put in a "void -&gt; void" function. 
The globalvarmap argument is a map of global CPS variables to llvalues. 
<BR><A NAME="src/llvm/cpsllvm.ml:19975"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> build_nodef name cpsbody globalvarmap = <BR>  
prepare_build name cpsbody <span style="color: #228b22; ">None</span> globalvarmap</P><P><A NAME="src/llvm/cpsllvm.ml:20068"></A>
<span style="color: #0000ff; font-weight: bold;">and</span> build_function name contparam param cpsbody =<BR>
<span style="color: #b22222">(&#X2217;  XXX: pass globalvarmap to functions too  &#X2217;)</span><BR>  
prepare_build name cpsbody (<span style="color: #228b22; ">Some</span> (contparam,param)) <span style="color: #228b22; ">Cpsbase.Var.Var.Map.</span>empty</P><P></code></div>
Build the function around the main term cpsbody, possibly taking
some parameters k and x. 
<BR><A NAME="src/llvm/cpsllvm.ml:20344"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>

<span style="color: #0000ff; font-weight: bold;">and</span> prepare_build name cpsbody param globalvarmap = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> params_type = <span style="color: #a020f0; ">match</span> param <span style="color: #a020f0; ">with</span> <span style="color: #228b22; ">None</span> &#X2192; [| |] &#X2223; _ &#X2192; [| anystar_type |] <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> function_type = <span style="color: #228b22; ">Llvm.</span>function_type anystar_type params_type <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #b22222">(&#X2217;  Note: it is important for LLVM that function names are unique.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> funname = name ^ <span style="color: #8b2252; ">"#"</span> ^ (<span style="color: #228b22; ">UniqueFunctionId.</span>to_string (<span style="color: #228b22; ">UniqueFunctionId.</span>fresh())) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> the_function = <span style="color: #228b22; ">Llvm.</span>declare_function funname function_type the_module <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> bb = <span style="color: #228b22; ">Llvm.</span>append_block context <span style="color: #8b2252; ">"entry"</span> the_function <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #b22222">(&#X2217;  Note that we use a new builder. We could even build the functions in parallel.  &#X2217;)</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> builder = <span style="color: #228b22; ">Llvm.</span>builder context <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #228b22; ">Llvm.</span>position_at_end bb builder;<BR>  
<span style="color: #a020f0; ">try</span> <BR>    
<span style="color: #0000ff; font-weight: bold;">let</span> initial_varmaps = <BR>      
<span style="color: #a020f0; ">match</span> param <span style="color: #a020f0; ">with</span> <BR>        
&#X2223; <span style="color: #228b22; ">None</span> &#X2192; (<span style="color: #228b22; ">Cpsbase.Cont_var.Var.Map.</span>empty, globalvarmap)<BR>        
&#X2223; <span style="color: #228b22; ">Some</span>(k,x) &#X2192; (<span style="color: #228b22; ">Cpsbase.Cont_var.Var.Map.</span>singleton k <span style="color: #228b22; ">Ret</span>,<BR>                        
<span style="color: #228b22; ">Cpsbase.Var.Var.Map.</span>add x (<span style="color: #228b22; ">Llvm.</span>param the_function 0) globalvarmap) <span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:21293"></A>    
ignore(build_term cpsbody initial_varmaps builder);<BR>    
<span style="color: #b22222">(&#X2217;  Prints the textual representation of the function to stderr.  &#X2217;)</span><BR>    
<span style="color: #228b22; ">Llvm.</span>dump_value the_function;<BR>    
<span style="color: #b22222">(&#X2217;  Validate the code we just generated.  &#X2217;)</span><BR>    
<span style="color: #228b22; ">Llvm_analysis.</span>assert_valid_function the_function;<BR>    
the_function<BR>  
<span style="color: #b22222">(&#X2217;  Normally, no exception should be thrown, be we never know.  &#X2217;)</span><BR>  
<span style="color: #a020f0; ">with</span> e &#X2192; <span style="color: #228b22; ">Llvm.</span>delete_function the_function; raise e</P><P><A NAME="src/llvm/cpsllvm.ml:21698"></A>
<span style="color: #0000ff; font-weight: bold;">let</span> build_toplevel toplevel globalvarmap = <BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> <span style="color: #228b22; ">Top</span>(defs) = toplevel <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> [(var,<span style="color: #228b22; ">Cpsbase.Dynamic_value</span>(expr))] = defs <span style="color: #0000ff; font-weight: bold;">in</span></P><P></code></div>  
The thunk is a function that returns the result. 
<BR><A NAME="src/llvm/cpsllvm.ml:21882"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
  
<span style="color: #0000ff; font-weight: bold;">let</span> thunk = build_nodef <span style="color: #8b2252; ">"nodef"</span> expr globalvarmap <span style="color: #0000ff; font-weight: bold;">in</span></P><P></code></div>  
We build an enclosing function that calls thunk and store its result. 
<BR>  
XXX: This is copy and paste from prepare_build, and should be factorized. 
<BR><A NAME="src/llvm/cpsllvm.ml:22098"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
  
<span style="color: #0000ff; font-weight: bold;">let</span> function_type = <span style="color: #228b22; ">Llvm.</span>function_type anystar_type [| |] <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> funname = <span style="color: #8b2252; ">"global"</span> ^ <span style="color: #8b2252; ">"#"</span> ^ (<span style="color: #228b22; ">UniqueFunctionId.</span>to_string (<span style="color: #228b22; ">UniqueFunctionId.</span>fresh())) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> the_function = <span style="color: #228b22; ">Llvm.</span>declare_function funname function_type the_module <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> bb = <span style="color: #228b22; ">Llvm.</span>append_block context <span style="color: #8b2252; ">"entry"</span> the_function <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> builder = <span style="color: #228b22; ">Llvm.</span>builder context <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #228b22; ">Llvm.</span>position_at_end bb builder;</P><P><A NAME="src/llvm/cpsllvm.ml:22469"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> initial_varmaps = (<span style="color: #228b22; ">Cpsbase.Cont_var.Var.Map.</span>empty, globalvarmap) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> result = <span style="color: #228b22; ">Llvm.</span>build_call thunk [||] <span style="color: #8b2252; ">"thunkresult"</span> builder <span style="color: #0000ff; font-weight: bold;">in</span></P><P><A NAME="src/llvm/cpsllvm.ml:22611"></A>  
<span style="color: #0000ff; font-weight: bold;">let</span> varname = <span style="color: #8b2252; ">"var"</span> ^ <span style="color: #8b2252; ">"#"</span> ^ (<span style="color: #228b22; ">UniqueFunctionId.</span>to_string (<span style="color: #228b22; ">UniqueFunctionId.</span>fresh())) <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #0000ff; font-weight: bold;">let</span> the_variable = <span style="color: #228b22; ">Llvm.</span>define_global varname undef_anystar the_module <span style="color: #0000ff; font-weight: bold;">in</span><BR>  
<span style="color: #228b22; ">Llvm.</span>build_store result the_variable builder;<BR>  
<span style="color: #228b22; ">Llvm.</span>build_ret null_anystar builder;</P><P></code></div>    
XXX: Probleme. Avec LLVM, les variables globales sont toujours
des pointeurs. Et je ne connais pas la taille du resultat de la
fonction. Donc si la valeur de retour du constructeur est de
type C value *, la variable globale contiendra value * (et sera
de type value ** ). Les accÃ¨s Ã  cette variable devront se faire
par des loads, contrairement aux variables locales.</P><P>Solution: les CPS vars devraient avoir un attribut, qui dirait
si ce sont des variables locales ou globales. 
<BR>    
XXX: llvm a un define_global initializer. Peut-etre qu&#X2019;on devrait utiliser cela? Comment ca s&#X2019;utilise 
<BR>    
Prints the textual representation of the function to stderr. 
<BR><A NAME="src/llvm/cpsllvm.ml:23589"></A>
<div style="border: solid 1px gray; background:#eeeeee;
            margin: 0.5em 1em 0.5em 1em;
            padding: 0.5em 1em 0.5em 1em;
            font-family:mono"><code>
    
<span style="color: #228b22; ">Llvm.</span>dump_value the_function;<BR>    
<span style="color: #228b22; ">Llvm.</span>dump_value the_variable;<BR>    
<span style="color: #b22222">(&#X2217;  Validate the code we just generated.  &#X2217;)</span><BR>    
<span style="color: #228b22; ">Llvm_analysis.</span>assert_valid_function the_function;</P><P><A NAME="src/llvm/cpsllvm.ml:23760"></A>    
<span style="color: #0000ff; font-weight: bold;">let</span> newmap = <span style="color: #a020f0; ">match</span> var <span style="color: #a020f0; ">with</span><BR>      
&#X2223; <span style="color: #228b22; ">Cpsbase.Public</span>(var) &#X2223; <span style="color: #228b22; ">Cpsbase.Private</span>(var) &#X2192; <span style="color: #228b22; ">Cpsbase.Var.Var.Map.</span>add var the_variable globalvarmap<BR>      
&#X2223; <span style="color: #228b22; ">Cpsbase.Unused</span> &#X2192; globalvarmap<BR>    
<span style="color: #0000ff; font-weight: bold;">in</span> (the_function, newmap)</P><P></code></div>
We build two functions; not ideal. The problem is that we would
like to do something else at the "halt" point. So: </P><P>XXX: Solution: halt should not write build_ret, but return the
builder and the value returned. In the end there should be only one
value returned by halt. We should be able to keep the
"End_of_block" thing, by just adding an alternative, which is
"halt". "halt" is not encountered when building lambdas or
functions, only when building nodefs.</P><P>- either we configure (maybe using "dynamic binding", or passing an
argument; or by just returning the builder at the right position
when "halt" is encountered, together with the returned value)
"halt" in build_term to be configurable</P><P>- Or we manage, in the CPS transformation, to have several
terminators (not just halt): Retvoid, Ret, or Writeglobal. Less
satisfactorily.</P><P><BR>  
let (constructor,newcpsllvalues) = 
<BR>  
Cpsllvm.build_toplevel toplevel envs.cpsllvalues in 
<BR></P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
