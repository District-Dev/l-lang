<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L language - blog</title>
    <description></description>
    <link>http://l-lang.org</link>
    <atom:link href="http://l-lang.org/blog-rss.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TDOP / Pratt parser in pictures</title>
      <description>&lt;div class=&quot;figure&quot;&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
The L parser has been cleaned up and is now commited on &lt;a href=&quot;http://github.com/lemerre/l-lang&quot;&gt;github&lt;/a&gt;. As
always, it is written in a literate programming style, and you can
have a look at the generated documents corresponding to its &lt;a href=&quot;/documentation/compiler_hyperbook/parser/tdop.mli&quot; alt=&quot;interface&quot;/&gt;interface&lt;/a&gt;
and &lt;a href=&quot;/documentation/compiler_hyperbook/parser/tdop.ml&quot; alt=&quot;implementation&quot;/&gt;implementation&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
For the implementation I wrote a big diagram explaining how TDOP
parsing works in practice. I also wrote a more interactive version of
this diagram below for this blog post.
&lt;/p&gt;

&lt;p&gt;
To understand this diagram, you should have a &lt;a href=&quot;/documentation/compiler_hyperbook/parser/tdop.mli&quot; alt=&quot;look at the tdop.mli
file&quot;/&gt;look at the tdop.mli
file&lt;/a&gt;, that defines the interface of the TDOP parser. For people in a
hurry, here is a summary of the main points:
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;TDOP defines a &lt;code&gt;parse&lt;/code&gt; function that will, in our case, parse an
expression.
&lt;/li&gt;
&lt;li&gt;TDOP works by associating parsing functions to tokens (and not to
rules, as in the case in classic parsing frameworks such as
bison/yacc, ANTR, or PEGs).
&lt;/li&gt;
&lt;li&gt;The parsing function called depend on the position of the token:
tokens at the beginning of an expression are in &quot;prefix&quot; position,
others are in &quot;infix&quot; position. This allows to handle things like
unary minus without resorting to lexing hacks.
&lt;/li&gt;
&lt;li&gt;Tokens are given two priorities: the left binding power and the
right binding power. If a string has a form &lt;code&gt;aEb&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
are tokens and &lt;code&gt;E&lt;/code&gt; is an expression, then the right binding power of
&lt;code&gt;a&lt;/code&gt; is compared to the left binding power of &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;E&lt;/code&gt; is associated
with the the token with the highest binding power.

&lt;p&gt;
This scheme is more powerful than classical operator precedence, and
in particular allows to deal with associativity.
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;The left binding power of a token is retrieved through a mapping
table. The right binding power is given by the parsing function
associated to a token as an argument to the &lt;code&gt;parse&lt;/code&gt; function.
&lt;/li&gt;
&lt;li&gt;The tdop.mli file of the L compiler allows to deal with separation
(i.e. spacing) between tokens, but I will not speak about them in
this post.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The following diagram will explain both how the parser works, and how
it is used to parse a simple mathematical expression.
&lt;/p&gt;

&lt;div class=&quot;carousel-no-transition&quot;&gt;
&lt;div id=&quot;my-carousel&quot; class=&quot;carousel&quot; data-ride=&quot;carousel&quot; data-interval=&quot;false&quot;
style=&quot;width: 712px; margin: 0 auto&quot;&gt;

  &lt;!-- Wrapper for slides --&gt;
  &lt;div class=&quot;carousel-inner&quot;&gt;
    &lt;div class=&quot;item active&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-0.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         The first call to the &lt;code&gt;parse&lt;/code&gt; function has a base right binding power of 0.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-1.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The first token encountered by &lt;code&gt;parse&lt;/code&gt; is, by definition, 
          in prefix position. The associated parsing function just asks &lt;code&gt;parse&lt;/code&gt; for another
          expression, with a high priority (3).
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-2.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         So &lt;code&gt;parse&lt;/code&gt; is called with a right binding power of 3.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-3.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         &lt;code&gt;parse&lt;/code&gt; finds &quot;a&quot; in prefix position.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-4.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
        &quot;a&quot; is a terminal symbol, with no further parsing action other than returning &quot;a&quot; as a parse tree.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-5.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;code&gt;parse&lt;/code&gt; finds &quot;+&quot; in infix position. However, the left binding power of &quot;+&quot; is 1,
          which is smaller than 3, the right binding power of that invocation of parse. So &quot;+&quot; is not 
          part of the expression, and &lt;code&gt;parse&lt;/code&gt; returns.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-6.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The parse function associated with &quot;-&quot; changes the &quot;a&quot; parsetree, and returns &quot;-a&quot;.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-7.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;code&gt;parse&lt;/code&gt; finds &quot;+&quot; in infix position. As the right binding power of that invocation
          of parse is 0, and the left binding power of &quot;+&quot; is 1, &quot;+&quot; is part of the expression.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-8.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The parsing function associated with infix &quot;+&quot; is called with the result of the parse so far (&quot;-a&quot;).
          This function just asks &lt;code&gt;parse&lt;/code&gt;for another expression, with a priority of 1.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-9.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         So &lt;code&gt;parse&lt;/code&gt; is called with a right binding power of 1.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-10.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
        &lt;code&gt;parse&lt;/code&gt; finds &quot;b&quot; in prefix position. &quot;b&quot; is a terminal symbol, 
        with no further parsing action other than returning &quot;b&quot; as a parse tree.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-11.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         &lt;code&gt;parse&lt;/code&gt; finds &quot;*&quot; in infix position. As the right binding power of that invocation
          of parse is 1, and the left binding power of &quot;*&quot; is 2, &quot;*&quot; is part of the expression. The 
          use of left and right priority thus allowed to express that &quot;*&quot; binds stronger than &quot;+&quot;.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-12.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The parsing function associated with infix &quot;*&quot; is called with the result of the parse so far (&quot;b&quot;).
          This function just asks &lt;code&gt;parse&lt;/code&gt;for another expression, with a priority of 2.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-13.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
       So &lt;code&gt;parse&lt;/code&gt; is called with a right binding power of 2.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-14.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
        &lt;code&gt;parse&lt;/code&gt; finds &quot;c&quot; in prefix position. &quot;c&quot; is a terminal symbol,
         with no further parsing action other than returning &quot;c&quot; as a parse tree.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-15.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         &lt;code&gt;parse&lt;/code&gt; finds &quot;+&quot; in infix position. However, the left binding power of &quot;+&quot; is 1,
          which is smaller than 2, the right binding power of that invocation of parse. So &quot;+&quot; is not 
          part of the expression, and &lt;code&gt;parse&lt;/code&gt; returns.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-16.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The parsing function associated to &quot;*&quot; combines the parse tree, received as an argument (&quot;b&quot;) 
          with the parsetree just returned &quot;c&quot; and returns the parsetree &quot;b*c&quot;. Thus the parse functions 
          associated with tokens are responsible for implementing semantic actions.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-17.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         &lt;code&gt;parse&lt;/code&gt; finds &quot;+&quot; in infix position. However, the left binding power of &quot;+&quot; is 1,
          which is not greater than 1, the right binding power of that invocation of parse. So &quot;+&quot; is not 
          part of the expression, and &lt;code&gt;parse&lt;/code&gt; returns. Tokens that have their left binding power 
          and right binding power equals are thus left-associative; to obtain right-associativity, the 
          right binding power should have been set to the &quot;left binding power minus 1&quot; (1-1 = 0 for the &quot;+&quot; token).
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-18.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
        The parsing function associated to &quot;+&quot; combines &quot;-a&quot; with &quot;b*c&quot; to return the parse tree &quot;(-a)+(b*c)&quot;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-19.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;code&gt;parse&lt;/code&gt; finds &quot;+&quot; in infix position. As the right binding power of that invocation
          of parse is 0, and the left binding power of &quot;+&quot; is 1, &quot;+&quot; is part of the expression
         (but in a left-associative way).
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-20.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The end is similar to what was already seen: the parsing function associated to &quot;+&quot; calls &lt;code&gt;parse&lt;/code&gt;...
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-21.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          which finds the terminal symbol &quot;d&quot;...
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-22.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          which is returned as a parse tree ...
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-23.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          Here, &lt;code&gt;parse&lt;/code&gt; finds the symbol &quot;end-of-file&quot; in infix position,
          which has a very low left binding power of 0, and thus cannot be part of any expression.
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-24.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
          The &quot;d&quot; parse tree is comined with &quot;(-a) + (b*c)&quot;...
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;img src=&quot;/img/tdop_example-25.png&quot; alt=&quot;Anim 0&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
         &lt;code&gt;parse&lt;/code&gt; finds &quot;end-of-file&quot; again, and returns the expression completely parsed.
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Controls --&gt;
  &lt;a class=&quot;left carousel-control&quot; href=&quot;#my-carousel&quot; data-slide=&quot;prev&quot;&gt;
    &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt;
  &lt;/a&gt;
  &lt;a class=&quot;right carousel-control&quot; href=&quot;#my-carousel&quot; data-slide=&quot;next&quot;&gt;
    &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;
This explanation is probably a bit short if you never encountered a
TDOP parser before, so I really encourage you to &lt;a href=&quot;/documentation/compiler_hyperbook/parser/tdop.mli&quot; alt=&quot;read tdop.mli&quot;/&gt;read tdop.mli&lt;/a&gt;, see
&lt;a href=&quot;/documentation/compiler_hyperbook/parser/expression.ml&quot; alt=&quot;how&quot;/&gt;how&lt;/a&gt; &lt;a href=&quot;/documentation/compiler_hyperbook/parser/definition.ml&quot; alt=&quot;it's&quot;/&gt;it's&lt;/a&gt; &lt;a href=&quot;/documentation/compiler_hyperbook/parser/path.ml&quot; alt=&quot;used&quot;/&gt;used&lt;/a&gt; in the L parser, or have a look at &lt;a href=&quot;http://javascript.crockford.com/tdop/tdop.html&quot;&gt;other&lt;/a&gt; &lt;a href=&quot;http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/&quot;&gt;nice&lt;/a&gt;
&lt;a href=&quot;http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing&quot;&gt;presentations&lt;/a&gt; of &lt;a href=&quot;http://effbot.org/zone/simple-top-down-parsing.htm&quot;&gt;TDOP&lt;/a&gt; on the internet (or of their implementation in
other languages than OCaml).
&lt;/p&gt;

&lt;p&gt;
I found that TDOP parsers were easy to implement, easy to use, and in
particular match well the thought process. I believe that human beings
distinguish &quot;-&quot; by this notion of &quot;prefix&quot; versus &quot;infix&quot; position,
for instance, and mentally parse strings using relative priority
between infix tokens; they are not expanding parsing rules to see if
one matches.
&lt;/p&gt;

&lt;p&gt;
In the future, I would like to experiment with TDOP-based parser
generation. The extension to EBNF notation that you can see in the
documentation of the parser allows to see what it could look like.
&lt;/p&gt;

&lt;p&gt;
A future blog article will present the syntax of the L language in
more details.
&lt;/p&gt;
</description>
      <pubDate>Fri, 03 Jan 2014 00:00:00 +0100</pubDate>
      <link>http://l-lang.org/blog/TDOP---Pratt-parser-in-pictures</link>
      <guid isPermaLink="true">http://l-lang.org/blog/TDOP---Pratt-parser-in-pictures</guid>
    </item>
    
    <item>
      <title>Structuring the compiler</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Simple is difficult&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
In the implementation of the L compiler, the focus was put on the
readability and simplicity of the source code. As often in computer
science, it is difficult to make things simple: I had a complete,
working prototype, with parser, typing, cps transformation and
compilation to LLVM when I started this blog; I spent all this time
cleaning, documenting, and especially simplifying the compiler,
publishing the progress along the way.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
I believe that the result is worth the work: a simpler compiler is
easier to extend, both for myself and future contributors. The
challenge will be to keep things easy as more features are added; this
is possible only if we wait for things to be well structured before
adding the non-essential features (for now, I just keep a huge
todo-list with those); and if we do not hesitate to perform a local
redesign occasionally.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Implementation of the toplevel of the compiler&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
The toplevel of the compiler, that link all the passes together, is a
good example of the results of such a redesign. A design goal of this
toplevel is to make each pass communicate with a minimal interface. I
had written a first attempt, using a record updated functionally, with
each field containing the internal state of one pass. The toplevel
consisted in a giant function with nested loops &amp;#x2013; one loop per pass.
This structure was inelegant for a number of reasons:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Even if the type of the state could be made abstract, the abstract
type was still part of the interface. Moreover, the initial value
for this type also had to be provided by the passes.
&lt;/li&gt;

&lt;li&gt;Updating the environment functionally introduced a lot of
boilerplate code; even if imperative updates might have helped a
little. 
&lt;/li&gt;

&lt;li&gt;There was also some boilerplate code to handle the case where a
single input could return multiple output (e.g. a datatype
declaration in ML defines both a type and some constructors).
&lt;/li&gt;

&lt;li&gt;The nested loop pattern was not really readable. 
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
After a while, I came up with a much simpler design using streams of
definitions. The code for a toplevel is then dead-simple:
&lt;/p&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Stream&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Extensions.Stream&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/compilation_passes.ml:3738&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; process_file file =&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; parsetree_stream = &lt;span style=&quot;color: #228b22; &quot;&gt;Parser.&lt;/span&gt;make_stream file &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; ast_stream = &lt;span style=&quot;color: #228b22; &quot;&gt;Astfromsexp.&lt;/span&gt;from_stream parsetree_stream &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; cps_stream = &lt;span style=&quot;color: #228b22; &quot;&gt;Cpstransform.&lt;/span&gt;from_stream ast_stream &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; converted_stream =&lt;BR&gt;    
&lt;span style=&quot;color: #228b22; &quot;&gt;Stream.&lt;/span&gt;iter_and_copy &lt;span style=&quot;color: #228b22; &quot;&gt;Cpsconvertclosures.&lt;/span&gt;in_definition cps_stream &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; llvm_stream = &lt;span style=&quot;color: #228b22; &quot;&gt;Cpsllvm.&lt;/span&gt;from_stream converted_stream &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;Stream.&lt;/span&gt;iter (&lt;span style=&quot;color: #a020f0; &quot;&gt;fun&lt;/span&gt; elt &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvmexec.&lt;/span&gt;exec_nodef () elt) llvm_stream&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;

&lt;p&gt;
The actual implementation also interposes optional printer to see the
contents of the stream, which is very useful when debugging the
compiler. 
&lt;/p&gt;

&lt;p&gt;
The stream interface make it easy to add new passes, completely remove
the state from the interface, factorize the pattern when a pass can
produce several elements at once, retain the minimal memory
consumption of the nested loop design, and can be easily updated to a
parallel pipelining implementation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Interface to the passes and modular implementation&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-3-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-1&quot;&gt;Interface of each pass&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-1&quot;&gt;
&lt;p&gt;
The interface of each pass is made minimal. Each pass only declares:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;The type of the elements in the stream (e.g. tokens, typed AST
definitions, CPS definitions&amp;#x2026;). The type is not abstract: it is
used by the following pass to convert them to its own representation
(e.g. the CPS pass use the AST type to perform CPS transformation,
the LLVM pass use the CPS type to compile to LLVM).
&lt;/li&gt;

&lt;li&gt;A function mapping an input stream to an output stream.
&lt;/li&gt;

&lt;li&gt;Possibly, a function to print elements in the stream, used for
debugging the compiler.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
And that is all. The interface of each pass clear is minimal, which
allows to study or change it independently.
&lt;/p&gt;

&lt;p&gt;
Note: this way of structuring things imply that transformation from
one pass to the next is done in the second pass. (This implies that
the second pass depends on the first one).
&lt;/p&gt;

&lt;p&gt;
An alternative is to expose functions to build elements in the second
pass, and move the transformation code from the beginning of the
second pass to the end of the first pass. In this case, the first pass
depends on the second pass. One advantage is that the first pass does
not have to expose the type of its internal format. I am considering
using this structure for the parser, where a &quot;parsetree&quot; is produced,
but whose type is not very interesting outside of the parsing phase;
while the building functions for the AST are more interesting.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-2&quot;&gt;Modules inside each pass&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-2&quot;&gt;
&lt;p&gt;
Inside each pass, the code is structured around a hierarchy of modules
and interfaces. The idea is that each interface progressively hides
more details about the implementation of the pass, until the top where
we get the minimal interface presented earlier. Intermediate levels
show up when we manage to group a complex piece of code into a simple
interface. For instance in the CPS pass, there are four intermediary
modules:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;CPStransform, performing AST to CPS transformation. Its
implementation consist of 4 sub-modules, that include the
compilation of pattern matching; its interface only consists of a
single function.
&lt;/li&gt;

&lt;li&gt;CPSconvertclosure is a slightly less complex algorithm; its
interface also consists in a single function.
&lt;/li&gt;

&lt;li&gt;CPSshrink will perform shrinking reductions and optimizations. I
have not yet implemented the cleaned version of this module.
&lt;/li&gt;

&lt;li&gt;CPSbase provides general functions for creating and updating CPS
terms; the interface of this module is more complex, but hides many
details about the internal CPS data structure (which is quite
complex), and prevents direct writes to this structure.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Structuring the code around hierarchical, modular interfaces and
implementations thus allow intermediate levels of abstractions; when
completing a task one is provided with just the needed information,
the right degree of abstraction; this helps to focus. The hierarchy
also decrease, and thus simplifies, the size of the interfaces. OCaml
was perfect for this job, but C, to a lesser extent, also allows this
kind of modular programming.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-3&quot;&gt;Comparison with object orientation&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-3&quot;&gt;
&lt;p&gt;
Note that this design is not at all object-oriented. I think that when
providing a new abstract type, packing it with all the methods
allowing to access or update objects of this type is an excellent
idea. However by using &lt;span class=&quot;underline&quot;&gt;only&lt;/span&gt; object-oriented interfaces, the tendency
is to to present all methods of an object in a flat manner, and
implement all of them in the same class and file. This is problematic
when there are many methods (which should be grouped by themes), or
that some methods are lengthy algorithms (the algorithm should be set
in a separate file). Modules allow such grouping and separation of
methods, while creating a new usual object-oriented classes would not
work (because we operate on an object defined in another class). Of
course there are object-oriented work-arounds; but I think that
modules and interfaces with abstract types solve the problem more
elegantly (while still allowing &quot;type + methods&quot;-style interfaces). I
hope that the code for the L compiler, written in OCaml, shows my
point.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      <pubDate>Sun, 30 Jun 2013 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/Structuring-the-compiler</link>
      <guid isPermaLink="true">http://l-lang.org/blog/Structuring-the-compiler</guid>
    </item>
    
    <item>
      <title>Compiling pattern matching</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
I have finished implementing the compilation of pattern matching for
L. L source code can now use ML-style patterns, as used in the
&lt;code&gt;match&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, and &lt;code&gt;fun/function&lt;/code&gt; operators of OCaml. See
&lt;a href=&quot;http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora016.html&quot;&gt;http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora016.html&lt;/a&gt; for
an example in OCaml if you don't know about pattern matching.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
Compilation of pattern matching happens together with the CPS
transformation phase of the compiler, which translates the &quot;AST&quot;
language (used in particular to perform type inference) to the &quot;CPS&quot;
language (in which jumps and order of computation is made explicit).
CPS transformation fixes the order of evaluation, so it makes sense to
perform pattern compilation during this phase.
&lt;/p&gt;

&lt;p&gt;
As the rest of the compiler, this module has been been written in
literate programming style (or at least, it is heavily commented, so
that it should be understandable by someone with no prior knowledge
of the subject). I have extracted the header of the module at the
bottom of this post.
&lt;/p&gt;

&lt;p&gt;
The next step is to finish cleaning the rest of the CPS transformation
(which is much easier); with this the entire backend of the compiler
will have been published.
&lt;/p&gt;

&lt;!--CUT DEF section 1 --&gt;&lt;!--TOC section Module Cpstransform_rules--&gt;
&lt;H3&gt;Module Cpstransform_rules &lt;/H3&gt;
&lt;A NAME=&quot;src/cps/cpstransform/cpstransform_rules.ml:0&quot;&gt;&lt;/A&gt;The Cpstransform_rules module handles the compilation of a set of &lt;EM&gt;rules&lt;/EM&gt;. A
&lt;EM&gt;rule&lt;/EM&gt; is composed of a pattern, matched against a value; and
an expression (the &lt;EM&gt;body&lt;/EM&gt; of the rule), to be executed if the
pattern succeeds in matching the value.&lt;/P&gt;&lt;P&gt;The &lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(expression){rules}&lt;/code&gt; expression matches an expression
against a set of rules; its behaviour is to evaluate the expression
once, and try to match the resulting value against the patterns in
&lt;code&gt;rules&lt;/code&gt; until one succeeds, in which case the corresponding body is
executed.&lt;/P&gt;&lt;P&gt;The order of the rules is thus important: a value can be matched by
the patterns of two rules, e.g. &lt;code&gt;(5,6)&lt;/code&gt; is matched by &lt;code&gt;(5,_)&lt;/code&gt; and
&lt;code&gt;(_,6)&lt;/code&gt;; but only the body of the first rule is executed. This
implies that two successive rules in a &lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;&lt;/code&gt; can be reordered if,
and only if, they are &lt;EM&gt;disjoint&lt;/EM&gt;, i.e. they cannot match the
same value.&lt;/P&gt;&lt;P&gt;But when allowed, reordering and factorizing the compilation of
rules matching lead to more compact, faster code. Trying to produce
the most efficient code for matching against a set of rules is a
NP-complete problem (the complexity arise when compiling multiple
independent patterns, for instance tuple patterns). Rather than
attempting to solve this problem, L specifies how pattern matching
is compiled, which allows the developper to visualize the costs of
its pattern matching.&lt;/P&gt;&lt;!--TOC subsubsection Pattern matching rewrites--&gt;
&lt;H4 CLASS=&quot;subsubsection&quot;&gt;&lt;!--SEC ANCHOR --&gt;Pattern matching rewrites&lt;/H4&gt;&lt;!--SEC END --&gt;&lt;P&gt;The compiler maintains a list of patterns that remain to be matched
for each rule, and a list of values against which each rule is
matched. The list of the first pattern to be matched in each rules
is the first column, and is matched against the first value.
Several cases can occur (see in the book &quot;The implementation of
functional programming languages&quot; by Simon Peyton Jones, the
chapter 5: &quot;Efficient compilation of pattern matching&quot;, by Philip
Wadler):&lt;/P&gt;&lt;!--TOC paragraph There is no more column--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;There is no more column&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt;When there are no remaining patterns to match, and no remaining
values, it means that all the rules match. As pattern matching
selects the first rule that matches, we execute the body of the
first rule, and discard the other rules with a warning.&lt;/P&gt;&lt;P&gt;For instance in&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; () &amp;#X2192; body1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; () &amp;#X2192; body2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;code&gt;body1&lt;/code&gt; matches and is executed; &lt;code&gt;body2&lt;/code&gt; also matches, but is
superseded by &lt;code&gt;body1&lt;/code&gt;, and is just discarded.&lt;/P&gt;&lt;!--TOC paragraph The column contain only variables--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;The column contain only variables&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt; In this case, in
each rule the variable is bound to the value, and matching
continues. For instance in&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(expr1,...){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (a,...) &amp;#X2192; body1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (b,...) &amp;#X2192; body2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;code&gt;a&lt;/code&gt; is bound to &lt;code&gt;v1&lt;/code&gt; in the first rule, and &lt;code&gt;b&lt;/code&gt; in the second rule;
where &lt;code&gt;v1&lt;/code&gt; is a CPS variable representing the result of computing
&lt;code&gt;expr1&lt;/code&gt; in the condition of the match (computation in the condition
is thus not repeated). Matching then proceeds, starting from the
second column.&lt;/P&gt;&lt;P&gt;This rule can be extended to incorporate wildcard (&lt;code&gt;_&lt;/code&gt;) patterns
(where nothing is bound), and all &lt;EM&gt;irrefutable&lt;/EM&gt; patterns.
A pattern is irrefutable if it does not contain any &lt;EM&gt;variant&lt;/EM&gt;.&lt;/P&gt;&lt;P&gt;For instance, consider&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;((expr1,expr2),...){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (a,...) &amp;#X2192; body1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (_,...) &amp;#X2192; body2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((c,d),...) &amp;#X2192; body3&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;The column contains only irrefutable patterns. Let &lt;code&gt;v1&lt;/code&gt; be a
CPS variable containing the evaluation of &lt;code&gt;expr1&lt;/code&gt;, and &lt;code&gt;v2&lt;/code&gt;
containing the evaluation of &lt;code&gt;expr2&lt;/code&gt;. Then &lt;code&gt;a&lt;/code&gt; is bound to
&lt;code&gt;(v1,v2)&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; to &lt;code&gt;v1&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;v2&lt;/code&gt;.&lt;/P&gt;&lt;!--TOC paragraph The column contains only calls to constructors--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;The column contains only calls to constructors&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt; A
&lt;EM&gt;constructor&lt;/EM&gt; is a specific version of a variant type; for
instance &lt;code&gt;3&lt;/code&gt; is a constructor of &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Int&lt;/span&gt;&lt;/code&gt;, &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;True&lt;/span&gt;&lt;/code&gt; a constructor of
&lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;, and &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(1,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;)&lt;/code&gt; a constructor of &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;List&lt;/span&gt;&lt;/code&gt;&amp;lt;&lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&amp;gt;.&lt;/P&gt;&lt;P&gt;Note that if the column contain a variant, then all the
constructors that it contains are of the same type: this is
necessary for the pattern matching to typecheck.&lt;/P&gt;&lt;P&gt;When two contiguous rules have different constructors at the same
place, they cannot match the same value simultaneously: they are
thus disjoint, and can be swapped. This allows to group the rules
according to the constructor in their first column (the order of
the rules within a group being preserved).&lt;/P&gt;&lt;P&gt;For instance,&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(expr1, expr2){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(a,&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(b,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;)),&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;) &amp;#X2192; body1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;) &amp;#X2192; body2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;,c) &amp;#X2192; body3&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(d,e),_) &amp;#X2192; body4 &lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;can be grouped as (preserving the order between rules 1 and 4, and
2 and 3) :&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(expr1, expr2){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(a,&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(b,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;)),&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;) &amp;#X2192; body1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(d,e),_) &amp;#X2192; body4&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;) &amp;#X2192; body2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;,c) &amp;#X2192; body3&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Then, the matching of contiguous rules with the same constructor
can be factorized out, as follow:&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; v1 = expr1 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; v2 = expr2 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(v1){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(hd,tl) &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;((hd,tl),v2){&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; ((a,&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(b,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;)), &lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;) &amp;#X2192; body1 &lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; ((d,e),_) &amp;#X2192; body4 &lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(v2){&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt; &amp;#X2192; body2 &lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; c &amp;#X2192; body3 &lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Note that the L compiler matches the values in the constructor
before matching the other columns of the tuple, as was exemplified
in the &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;&lt;/code&gt; rules.&lt;/P&gt;&lt;P&gt;The construct of matching only the constructors of a single variant
type can be transformed directly into the CPS &lt;code&gt;case&lt;/code&gt; expression. It
is generally compiled very efficiently into a jump table, and
dispatching to any rule is done in constant time. (Note that the
compiler may not generate a jump table if the list of constructors
to check is sparse).&lt;/P&gt;&lt;!--TOC paragraph The first column contains both refutable and irrefutable
patterns--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;The first column contains both refutable and irrefutable
patterns&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt;If the first column contains both kind of patterns, the list of
rules is split into groups such that the ordering between rules is
preserved, and either all the rules in the group have their first
pattern that is refutable, or they are all irrefutable.&lt;/P&gt;&lt;P&gt;For instance, the following match:&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;((v1,v2),v3){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (_,1) &amp;#X2192; 1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((a,b),2) &amp;#X2192; a+b+2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((3,_),3) &amp;#X2192; ...&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((4,_),_) &amp;#X2192; ...&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((_,5),_) &amp;#X2192; ...&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((a,b),c) &amp;#X2192; a+b+c&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;is split into three groups, with respectively rules 1-2 (&lt;code&gt;_&lt;/code&gt; and
&lt;code&gt;(a,b)&lt;/code&gt; are both irrefutable patterns), rules 3-5, and rule 6. Then
the groups are matched successively, the next group being matched
only if no rule matched in the first one. This amount to performing
the following transformation:&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; c = ((v1,v2),v3) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(c){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; (_,1) &amp;#X2192; 1&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; ((a,b),2) &amp;#X2192; a+b+2&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; _ &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(c){&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; ((3,_),3) &amp;#X2192; ...&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; ((4,_),_) &amp;#X2192; ...&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; ((_,5),_) &amp;#X2192; ...&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; _ &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(c){&lt;/code&gt;&lt;BR&gt;
         &lt;code&gt; ((a,b),c) &amp;#X2192; a+b+c&lt;/code&gt;&lt;BR&gt;
         &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Note that rules 3,4,5 also need to be split and transformed further
using this method.&lt;/P&gt;&lt;!--TOC subsubsection Compiling pattern matching--&gt;
&lt;H4 CLASS=&quot;subsubsection&quot;&gt;&lt;!--SEC ANCHOR --&gt;Compiling pattern matching&lt;/H4&gt;&lt;!--SEC END --&gt;&lt;!--TOC paragraph Compilation order--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;Compilation order&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt;The order in which checking is made for a set of patterns is a
choice, done by the compiler. L chooses to match the tuples from
left to right, and the contents of the constructor as soon as they
are matched; and to split rules according to the refutability of
the pattern in their first remaining column. This choice may not be
optimal in every case (but minimizing the number of matches is a
NP-hard problem), but allows for a simple, visual analysis of the
cost of pattern matching. The user is free to rearrange the set of
patterns to improve performance (possibly guided by compiler
hints).&lt;/P&gt;&lt;!--TOC paragraph Element retrieval--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;Element retrieval&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt;At the beginning of a match, all the components, needed by at least
one rule, that can be retrieved (i.e. components in a tuple etc.,
but not those that are under a specific constructor) are retrieved.
When a constructor is matched, all the components that can be
retrieved that were under this constructor are retrieved. This
behaviour produces the most compact code (avoid duplicating
retrieval of elements in the compilation of several rules), but
maybe not the most efficient (sometimes elements are retrieved that
are not used). Optimizations, such as shrinking reductions, are
allowed to move down or even duplicate code performing retrieval of
elements into the case.&lt;/P&gt;&lt;!--TOC paragraph CPS--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;CPS&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt;Compilation of pattern matching is done during the CPS
transformation, which transforms source code from the AST language
to the CPS language. There are several reasons for that:&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;The CPS transformation of expression fixes the order of their
evaluation; compiling pattern matching fixes the order in which
patterns are matched. So it makes sense to do both at the same
time, to have a single pass that fixes all the order of evaluation.&lt;P&gt;As a side note, it makes sense to keep pattern matching in the AST
language, because patterns are easy to type, and any typing error
can be more easily returned to the user.&lt;/P&gt;&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;The CPS language provides continuations, which allows to
express explicit join points in the control flow, something not
possible in the AST language (without creating new functions).
These joint points are necessary notably to factorize the
compilation of pattern matching (this problem is similar to
compilation of boolean expressions with the short-circuit operators
&lt;CODE&gt;&amp;amp;&amp;amp;&lt;/CODE&gt; and &lt;CODE&gt;||&lt;/CODE&gt;). For instance, compiling:&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(v){ (4,5) &amp;#X2192; 1; _ &amp;#X2192; 2 }&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;gives:&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; k_not4_5() = { kreturn(2) }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(#0(v)){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; 4 &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(#1(v)){&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; 5 &amp;#X2192; kreturn(1)&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; _ &amp;#X2192; k_not4_5()&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; _ &amp;#X2192; k_not4_5()&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Matching against &lt;code&gt;(4,5)&lt;/code&gt; can fail at two different steps, and the
action to perform in these two cases are the same, so they should
be factorized using the same continuation.&lt;/P&gt;&lt;P&gt;The L compiler does not yet allow it, but &quot;or-patterns&quot; (i.e. in
&lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(l){ &lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;&amp;#X2223;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(_,&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;)) &amp;#X2192; 0 _ &amp;#X2192; 1 }&lt;/code&gt;) also need join
points. Finally, there is also a joint point (in
&lt;code&gt;expr_env.context&lt;/code&gt;) to which the value of the bodies in each rule
is returned.
&lt;/P&gt;&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt;All the functions that involve building CPS code are themselves in
CPS style; see the &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cps_transform_expression&lt;/span&gt;&lt;/code&gt; module for an
explanation.&lt;/P&gt;&lt;!--TOC paragraph A complete example--&gt;
&lt;H5 CLASS=&quot;paragraph&quot;&gt;&lt;!--SEC ANCHOR --&gt;A complete example&lt;/H5&gt;&lt;!--SEC END --&gt;&lt;P&gt;Here is a (contrived) exemple of a complete pattern matching:&lt;/P&gt;&lt;P&gt;&lt;IMG SRC=&quot;/img/cpstransform_rules.ml001.png&quot;&gt;&lt;/P&gt;&lt;P&gt;This pattern is compiled as follows. We begin by creating a join
continuation, which is where the result of the match is returned.
This allows to factorize the following computation (the addition to
17 in our case).&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; kfinal(x) = { &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; x17 = x + 17 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; halt(x17) }&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Then, the condition of the match &lt;code&gt;e&lt;/code&gt; is evaluated, and its result
stored in a temporary value.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; v = ... eval e ...&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Then, analysis of the patterns show that &lt;code&gt;v&lt;/code&gt; contains a tuple.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; v.0 = #0(v)&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; v.1 = #1(v)&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;Analysis of the patterns also show that &lt;code&gt;v.0&lt;/code&gt; contain a tuple.
&lt;code&gt;v.1&lt;/code&gt; is a variant type, so its elements cannot be retrieved yet.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; v.0.0 = #0(v.0)&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; v.0.1 = #1(v.0)&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;We begin by analysis the whole pattern (i.e. column &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;0&lt;/SUB&gt;). All the
rules are refutable, except the last one, so we split them into two
contiguous blocks &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;&lt;/SUB&gt; and &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;ii&lt;/I&gt;&lt;/SUB&gt;; &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;ii&lt;/I&gt;&lt;/SUB&gt; is executed if
matching against all the rules in &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;&lt;/SUB&gt; fail.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;decl kb_ii&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;All the rules in &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;&lt;/SUB&gt; are tuples, so we inspect them from left to
right (i.e. we begin by column &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;1&lt;/SUB&gt;, then proceed with &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;4&lt;/SUB&gt;).
Analysis of column &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;1&lt;/SUB&gt; yields three contiguous blocks: the
patterns in column &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;1&lt;/SUB&gt; are all irrefutable for block &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;a&lt;/I&gt;&lt;/SUB&gt;,
refutable for block &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;b&lt;/I&gt;&lt;/SUB&gt;, and irrefutable again for block
&lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;c&lt;/I&gt;&lt;/SUB&gt;.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;decl kb_i.b, kb_i.c&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;As the patterns of column &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;1&lt;/SUB&gt; in rules in &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;a&lt;/I&gt;&lt;/SUB&gt; are all
irrefutable, we just have to associate the variable &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;v.0.0&lt;/code&gt;
and &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;v.0.1&lt;/code&gt; for the translation of the body of the rules.
(&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are unused in the rules of the example).&lt;/P&gt;&lt;P&gt;We can then proceed with the analysis of column &lt;I&gt;c&lt;/I&gt;&lt;SUB&gt;2&lt;/SUB&gt; (still in
block &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;a&lt;/I&gt;&lt;/SUB&gt;). It is a variant, so we can regroup the rules
according to the constructor, and perform a simple case analysis.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;decl kcons&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(v.1){&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt; &amp;#X2192; { kfinal(2) }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;(x) &amp;#X2192; { kcons(x) } &lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;For the &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;&lt;/code&gt; constructor, we are already done. For &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;&lt;/code&gt;, we have
to discriminate against the patterns inside the &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;&lt;/code&gt;. But first,
we analyze these patterns to retrieve all the elements that are
needed:&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; kcons(x) = {&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; x.0 = #0(x)&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; x.1 = #1(x)&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; x.0.0 = #0(x.0)&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; x.0.1 = #1(x.0)&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;There are two contiguous blocks: one with rule 1 and 3 (since rule
2 has been regrouped with the &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;), and one with rule 4. We begin
with the 1-3 block:&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt; decl knext&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(x.0.0){&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; 1 &amp;#X2192; { kfinal(1)}&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; 3 &amp;#X2192; { kfinal(3)}&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; _ &amp;#X2192; { knext()}&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; }&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;If matching against the 1-3 block fails, we match against rule 4.
If this fails, then matching against all the rules in &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;a&lt;/I&gt;&lt;/SUB&gt;
failed, and we try to match against the rules in &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;b&lt;/I&gt;&lt;/SUB&gt;.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; knext() = {&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt;(x.0.1){&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; 4 &amp;#X2192; { kfinal(4)}&lt;/code&gt;&lt;BR&gt;
     &lt;code&gt; _ &amp;#X2192; { kb_i.b()}&lt;/code&gt;&lt;BR&gt;
   &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt; }&lt;/code&gt;&lt;BR&gt;
 &lt;code&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;The rest of the matching is very similar. In &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;b&lt;/I&gt;.1&lt;/SUB&gt;, the
matching against rules 5 and 7 is factorized, because there is a
common constructor. (Note that there is no factorization on &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;&lt;/code&gt;
between rules 4 and 5, because they are in different blocks). Then
blocks &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;b&lt;/I&gt;.2&lt;/SUB&gt;, &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;b&lt;/I&gt;.3&lt;/SUB&gt;, &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;c&lt;/I&gt;&lt;/SUB&gt; are tried successively.
In &lt;I&gt;b&lt;/I&gt;&lt;SUB&gt;&lt;I&gt;i&lt;/I&gt;.&lt;I&gt;c&lt;/I&gt;&lt;/SUB&gt;, the test of &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cons&lt;/span&gt;&lt;/code&gt; is factorized, but not the test
for &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;, because testing &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Nil&lt;/span&gt;&lt;/code&gt; is done after testing &lt;code&gt;10&lt;/code&gt;.&lt;/P&gt;&lt;P&gt;Finally, the pattern matching always succeeds since rule 12 is
irrefutable, so there is no need to introduce code that perform
&lt;code&gt;match_failure&lt;/code&gt; in case nothing succeeds in matching.&lt;/P&gt;&lt;P&gt;Note that the presentation would have been clearer if the patterns
had been regrouped differently; in particular, grouping rules who
share a constructor matched as the same time (e.g. exchanging rules
1 and 2, and rule 5 and 6) would improve the presentation.&lt;/P&gt;&lt;!--CUT END --&gt;
</description>
      <pubDate>Tue, 28 May 2013 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/Compiling-pattern-matching</link>
      <guid isPermaLink="true">http://l-lang.org/blog/Compiling-pattern-matching</guid>
    </item>
    
    <item>
      <title>A framework for CPS transformation (and a Github account)</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
I have implemented a framework for efficient transformation of CPS
code. The code is too big to be presented in a blog post; I have set
up a github account to put it (&lt;a href=&quot;https://github.com/mlemerre/l-lang/&quot;&gt;https://github.com/mlemerre/l-lang/&lt;/a&gt;).
It has been working for several months, but I have spent a long time
to improve its structure, write commented interfaces, and document it
to make it easily readable, as I have done with the previous modules.
Do not hesitate to tell me about any comments you may have, on the
code or documentation.
&lt;/p&gt;

&lt;p&gt;
The code is based on the paper &quot;Compiling with continuations,
continued&quot; by Andrew Kennedy (which is very well written and easy to
read), itself inspired by &quot;Shrinking lambda expressions in linear
time&quot;, by Andrew W. Appel and Trevor Jim.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
The CPS representation in Andrew Kennedy's paper provides many
interesting features:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;It is efficiently compilable and can use a stack; see &lt;a href=&quot;http://l-lang.blogspot.fr/2012/08/cps-to-llvm-ssa-conversion-in-literate_3067.html&quot;&gt;the
translation of this representation&lt;/a&gt; to the SSA form of LLVM.
&lt;/li&gt;

&lt;li&gt;The representation separates continuation from normal functions;
this ensures that continuations do not require heap allocations and
are compiled into jumps. This allows to express control flow, and
control flow optimizations, in the representation.
&lt;/li&gt;

&lt;li&gt;Appel and Jim, and Kennedy have developed a representation that
allows efficient (in-place) rewrite of terms while maintaining the
links between variables, their occurrences, and their binding sites.
This allows to implement shrinking reductions (and other
transformations, such as closure conversion) in linear time.

&lt;p&gt;
Shrinking reductions rules are very easy to understand, and can be
used as a basis for expressing guaranteed optimizations. For
instance, it should be easy to state that functions used only once
are inlined, that tuples used only to pass information locally are
not heap-allocated, etc.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The modules I have implemented provide means to access, print, or
change terms in the CPS intermediary language. The main modules, are
represented on the figure below.
&lt;/p&gt;


&lt;div class=&quot;figure&quot;&gt;
&lt;p&gt;&lt;img src=&quot;/img/cpsmodulesgraph.png&quot; alt=&quot;Graph of CPS modules&quot; title=&quot;Graph of CPS modules&quot; style=&quot;margin:0px auto;display:block&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
The &lt;code&gt;Base&lt;/code&gt; module is the entry point for accessing the CPS
representation, and the first module if trying to understand my code.
It provides read-only direct access to the CPS representation, and to
the links between variables, occurrences, and their binding sites. It
also gives access to the other modules that implement the CPS
manipulation framework:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;code&gt;Ast&lt;/code&gt;: Really a part of &lt;code&gt;Base&lt;/code&gt; representation, it provides access to
the CPS representation using simple algebraic datatypes of syntax
tree.
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Check&lt;/code&gt;: Allows checking for some invariants of terms in the CPS
representation. Some information in the representation is redundant,
which allows fast access; this module checks that redundant
information is in sync. For instance, if a term contains a variable,
it checks that the variable's uplink also points to that term.
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Build&lt;/code&gt;: Provides functions that allows to create new terms in the
CPS representation, without worrying about the complexities of the
representation. The API of this module is based on the idea of
higher-order abstract syntax, i.e. where binding creations in the
destination language (L) language correspond to creation of bindings
in the source language (OCaml).
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Traverse&lt;/code&gt;: Allows folding and iteration on the terms, variables,
and occurrences of the CPS representation. Using this module allows,
in particular, code to be independent of future changes to the CPS
data structures, which will be gradually improved.
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Change&lt;/code&gt;: Provides high-level functions to change CPS terms. This is
how transformation passes modify terms in the CPS representation.
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Print&lt;/code&gt;: Provides a human-readable representation of the CPS form. I
have tried to come up with a representation that is &quot;easy&quot; to read;
the representation looks more like SSA and/or assembly than
classical lambda-calculus (which make it much easier to read on huge
terms). This textual representation should also be easily parsable
(although I did not write the parser).
&lt;/li&gt;

&lt;li&gt;&lt;code&gt;Def&lt;/code&gt;: Implements and provides accessors and a first level of
abstraction to the CPS data structures. It relies on &lt;code&gt;Var&lt;/code&gt;, which
implements the relationships between variables and their occurrences
(itself based on the &lt;code&gt;Union_find&lt;/code&gt; data structure described &lt;a href=&quot;http://l-lang.blogspot.fr/2012/10/a-literate-union-find-data-structure.html&quot;&gt;earlier
on this blog&lt;/a&gt;).
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The other modules on the figure are &lt;code&gt;Union_find&lt;/code&gt; and &lt;code&gt;Unique&lt;/code&gt;, which
are &quot;support&quot; modules; and &lt;code&gt;Closure_conversion&lt;/code&gt; and
&lt;code&gt;Shrinking_reductions&lt;/code&gt;, which are transformation passes on the CPS
representation. These two passes are not yet in the github repository.
&lt;/p&gt;

&lt;p&gt;
I have a working closure conversion that gives me a complete basic
working compiler for the L programming language, based on this CPS
framework. I plan to document it and upload it to github very soon. I
also have implemented some basic shrinking reductions.
&lt;/p&gt;

&lt;p&gt;
Next I will concentrate on the parser and the L abstract syntax tree,
and I will be will be covering the syntax and semantics of L in a
future blog post. But here is already an excerpt of test L code (that
uses first-class functions) that can be compiled to LLVM:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
assert( { let true = { (x,y) -&amp;gt; x }
	  let false = { (x,y) -&amp;gt; y }
	  let pair = { (first,second) -&amp;gt; boolean -&amp;gt; boolean( first, second) }
	  let first = { p -&amp;gt; p( true)}
	  let second = { p -&amp;gt; p( false)}
	  let p = pair( 7, 5)
	  second( p) * (first( p) + second( p)) } == 60)
&lt;/pre&gt;
</description>
      <pubDate>Sun, 30 Dec 2012 00:00:00 +0100</pubDate>
      <link>http://l-lang.org/blog/A-framework-for-CPS-transformation-and-a-Github-account</link>
      <guid isPermaLink="true">http://l-lang.org/blog/A-framework-for-CPS-transformation-and-a-Github-account</guid>
    </item>
    
    <item>
      <title>Using OCaml packages with ocamlbuild: a recipe</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
Using OCaml packages with ocamlbuild can raise different error
messages that are difficult to trace; there is a documentation (
&lt;a href=&quot;http://brion.inria.fr/gallium/index.php/Ocamlbuild_and_module_packs&quot;&gt;http://brion.inria.fr/gallium/index.php/Ocamlbuild_and_module_packs&lt;/a&gt; )
that helps, but does not provide a step-by-step guide with common
pitfalls, so here is one.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Compilation of bytecode files&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
First create a project with the following files:
&lt;/p&gt;

&lt;p&gt;
File: plu/bla.ml
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;bla &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; 3&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
File: plu/bli.ml
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;bli &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #228b22;&quot;&gt;Bla&lt;/span&gt;.bla&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
File: plu.mlpack
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
plu/Bla
plu/Bli
&lt;/pre&gt;

&lt;p&gt;
File: use.ml
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;Plu&lt;/span&gt;.&lt;span style=&quot;color: #228b22;&quot;&gt;Bli&lt;/span&gt;.bli
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Note: all the files do not have to be in a directory named plu/; this
is just my convention.
&lt;/p&gt;

&lt;p&gt;
Try to compile:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
ocamlbuild use.byte
/usr/bin/ocamlc -c -o use.cmo use.ml
+ /usr/bin/ocamlc -c -o use.cmo use.ml
File &quot;use.ml&quot;, line 1, characters 0-11:
Error: Unbound module Plu
Command exited with code 2.
&lt;/pre&gt;

&lt;p&gt;
Compilation will not work, probably because by default Ocamlbuild does
not traverse directories. It will work if you use the &lt;code&gt;-r&lt;/code&gt; option to
ocamlbuild, or create a (even empty) &lt;code&gt;_tags&lt;/code&gt; file at the root of the
project, that will allow ocamlbuild to traverse the directories:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
ocamlbuild use.byte
/usr/bin/ocamldep -modules plu/bla.ml &amp;gt; plu/bla.ml.depends
/usr/bin/ocamldep -modules plu/bli.ml &amp;gt; plu/bli.ml.depends
/usr/bin/ocamlc -c -I plu -o plu/bla.cmo plu/bla.ml
/usr/bin/ocamlc -c -I plu -o plu/bli.cmo plu/bli.ml
/usr/bin/ocamlc -pack plu/bla.cmo plu/bli.cmo -o plu.cmo
/usr/bin/ocamlc -c -o use.cmo use.ml
/usr/bin/ocamlc plu.cmo use.cmo -o use.byte
&lt;/pre&gt;

&lt;p&gt;
Notice that ocamlbuild has added &lt;code&gt;-I plu&lt;/code&gt; when compiling modules of
the &lt;code&gt;Plu&lt;/code&gt; package; so for instance, &lt;code&gt;Bli&lt;/code&gt; can access &lt;code&gt;Bla&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
This odd behaviour can be the cause of many headaches, so I prefer to
document it here (and I filed a bug report about this issue &lt;a href=&quot;http://caml.inria.fr/mantis/view.php?id=5851&quot;&gt;here&lt;/a&gt;).
&lt;/p&gt;

&lt;p&gt;
Also note that if you make a mistake in the &lt;code&gt;plu.mlpack&lt;/code&gt; file, for
instance an error in the name of the directory or in that of the
module, ocamlbuild will fail without much warning. It will fail with a
compile error, as before; it may also fail at the linking step, if you
make a mistake in the &lt;code&gt;plu.mlpack&lt;/code&gt; file, but you had successfully
compiled a previous version. This problem can also be painful to
track, so I hope this help someone.
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
ocamlbuild use.byte
/usr/bin/ocamlc use.cmo -o use.byte
+ /usr/bin/ocamlc use.cmo -o use.byte
File &quot;_none_&quot;, line 1, characters 0-1:
Error: Error while linking use.cmo:
Reference to undefined global `Plu'
Command exited with code 2.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Adding native compilation&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
You cannot pack a set of &lt;code&gt;.cmx&lt;/code&gt; files (resulting from compilation of a
file) if you did not specified that the &lt;code&gt;.cmx&lt;/code&gt; can be packed when you
compile the file. Failure to do that result in an error like this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
ocamlbuild use.native
/usr/bin/ocamldep -modules use.ml &amp;gt; use.ml.depends
/usr/bin/ocamldep -modules plu/bla.ml &amp;gt; plu/bla.ml.depends
/usr/bin/ocamldep -modules plu/bli.ml &amp;gt; plu/bli.ml.depends
/usr/bin/ocamlc -c -I plu -o plu/bla.cmo plu/bla.ml
/usr/bin/ocamlc -c -I plu -o plu/bli.cmo plu/bli.ml
/usr/bin/ocamlc -pack plu/bla.cmo plu/bli.cmo -o plu.cmo
/usr/bin/ocamlc -c -o use.cmo use.ml
/usr/bin/ocamlopt -c -I plu -o plu/bla.cmx plu/bla.ml
/usr/bin/ocamlopt -c -I plu -o plu/bli.cmx plu/bli.ml
touch plu.mli  ;\
  if  /usr/bin/ocamlopt -pack -I plu plu/bla.cmx plu/bli.cmx -o plu.cmx  ;\
  then  rm -f plu.mli  ; else  rm -f plu.mli  ; exit 1; fi
+ touch plu.mli  ;\
  if  /usr/bin/ocamlopt -pack -I plu plu/bla.cmx plu/bli.cmx -o plu.cmx  ;\
  then  rm -f plu.mli  ; else  rm -f plu.mli  ; exit 1; fi
File &quot;plu.cmx&quot;, line 1, characters 0-1:
Error: File plu/bla.cmx
was not compiled with the `-for-pack Plu' option
Command exited with code 1.
&lt;/pre&gt;

&lt;p&gt;
The lines:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
/usr/bin/ocamlopt -c -I plu -o plu/bla.cmx plu/bla.ml
/usr/bin/ocamlopt -c -I plu -o plu/bli.cmx plu/bli.ml
&lt;/pre&gt;

&lt;p&gt;
Need to be compiled with the &lt;code&gt;-for-pack Plu&lt;/code&gt; option. This is achieved
by a simple change in the &lt;code&gt;_tags&lt;/code&gt; file: just fill it with
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
&amp;lt;plu/*.cmx&amp;gt;: for-pack(Plu)
&lt;/pre&gt;

&lt;p&gt;
And now everything works:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
ocamlbuild use.native
/usr/bin/ocamldep -modules use.ml &amp;gt; use.ml.depends
/usr/bin/ocamldep -modules plu/bla.ml &amp;gt; plu/bla.ml.depends
/usr/bin/ocamldep -modules plu/bli.ml &amp;gt; plu/bli.ml.depends
/usr/bin/ocamlc -c -I plu -o plu/bla.cmo plu/bla.ml
/usr/bin/ocamlc -c -I plu -o plu/bli.cmo plu/bli.ml
/usr/bin/ocamlc -pack plu/bla.cmo plu/bli.cmo -o plu.cmo
/usr/bin/ocamlc -c -o use.cmo use.ml
/usr/bin/ocamlopt -c -for-pack Plu -I plu -o plu/bla.cmx plu/bla.ml
/usr/bin/ocamlopt -c -for-pack Plu -I plu -o plu/bli.cmx plu/bli.ml
touch plu.mli  ;\
  if  /usr/bin/ocamlopt -pack -I plu plu/bla.cmx plu/bli.cmx -o plu.cmx  ;\
  then  rm -f plu.mli  ; else  rm -f plu.mli  ; exit 1; fi
/usr/bin/ocamlopt -c -o use.cmx use.ml
/usr/bin/ocamlopt plu.cmx use.cmx -o use.native
&lt;/pre&gt;

&lt;p&gt;
I will update this post if/when I find more weird error messages using
packages with ocamlbuild; or if you find such error, just tell me!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Update: linking problem when refering to modules outside of the package&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
I discovered a new problem with ocamlbuild. The problems occur when
you put code in a library which is included, and referenced only
inside of a package; in that case ocamlbuild forgets to link with the
library. The problem is well described &lt;a href=&quot;https://sympa.inria.fr/sympa/arc/caml-list/2010-06/msg00172.html&quot;&gt;in this mail&lt;/a&gt;. The author of
that mail also provides a ocamlbuild plugin that works around the
problem.
&lt;/p&gt;

&lt;p&gt;
This seems to be a classical bug, and there is a pending bug report
for it &lt;a href=&quot;http://caml.inria.fr/mantis/view.php?id=5752&quot;&gt;here&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      <pubDate>Thu, 20 Dec 2012 00:00:00 +0100</pubDate>
      <link>http://l-lang.org/blog/Using-OCaml-packages-with-ocamlbuild-a-recipe</link>
      <guid isPermaLink="true">http://l-lang.org/blog/Using-OCaml-packages-with-ocamlbuild-a-recipe</guid>
    </item>
    
    <item>
      <title>A literate union-find data structure</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
I have a working closure conversion done using the purely functional
CPS data structure presented in my earlier post, but it is somewhat
hackish. Thus I am trying to improve it, following Andrew Kennedy's
excellent paper &quot;Compiling with continuations, continued&quot;. 
&lt;/p&gt;

&lt;p&gt;
Kennedy's CPS structure requires a &lt;a href=&quot;http://en.wikipedia.org/wiki/Disjoint-set_data_structure&quot;&gt;union-find data structure&lt;/a&gt;, used to
merge the occurences of a variable, and find the binding site of an
occurence. I already had a union-find data structure, used to
implement first-order &lt;a href=&quot;http://en.wikipedia.org/wiki/Unification_(computer_science)&quot;&gt;unification&lt;/a&gt; in &lt;a href=&quot;http://en.wikipedia.org/wiki/Type_inference&quot;&gt;type inference&lt;/a&gt;, but as is usual a
module becomes good on the second time you write it (when you have
more experience about its implementation and usage).
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
There are many possible variations in the interface of a union-find
module. The particularities of this one is explicit support for
attaching description to sets, and a &quot;partition&quot; type separate from
the &quot;element&quot; type. Also, the interface is functorial, and I provided
two versions: a Safe one that checks that usage of the structure is
correct, and a Fast one with no check. It is easy to shoot yourself in
the foot by using this module incorrectly, so using the Safe one is
probably a better bet.
&lt;/p&gt;

&lt;p&gt;
So here they are.
&lt;/p&gt;

&lt;!--CUT DEF section 1 --&gt;&lt;!--TOC section Interface for module Union_find--&gt;
&lt;H2 CLASS=&quot;section&quot;&gt;&lt;!--SEC ANCHOR --&gt;Interface for module Union_find&lt;/H2&gt;&lt;!--SEC END --&gt;&lt;P&gt;
&lt;B&gt;1.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.mli:0&quot;&gt;&lt;/A&gt;&lt;A NAME=&quot;src/support/union_find.mli:42&quot;&gt;&lt;/A&gt;A union-find data structure maintains a partition of elements into
disjoint sets.&lt;/P&gt;&lt;P&gt;It allows to add new elements in new partitions, perform the union
of two partitions, and retrieve the partition in which is an
element. Moreover it allows to attach a description to a partition,
which is generally the point of using such a structure.&lt;/P&gt;&lt;P&gt;This module has side effects: adding an element to a union-find
data structure changes that element, and the union operation merges
the partitions destructively. This make it easy to use this module
incorrectly. To that end, a number of protections (using types and
dynamic checks) are set that detect such incorrect uses of the
module. &lt;/P&gt;&lt;P&gt;Note on the name: there are other data structures that maintain
disjoint sets with other operations, such as partition refinement,
so &quot;union-find&quot; is a more accurate name for this data structure
than &quot;disjoint set&quot;. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:969&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;S&lt;/span&gt; =&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;sig&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
The t type represents the whole union-find data structure. A
partition always belong to some t; elements belong to a t once
there has been a &quot;singleton&quot; operation on them. &lt;/P&gt;&lt;P&gt;All the functions (except &lt;code&gt;create&lt;/code&gt;) take a &lt;code&gt;t&lt;/code&gt; argument; in their
safe version this argument is used to checks that other
&lt;code&gt;element&lt;/code&gt; and &lt;code&gt;partition&lt;/code&gt; arguments indeed belong to the &lt;code&gt;t&lt;/code&gt;
argument. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:1395&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; partition&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
&lt;code&gt;create()&lt;/code&gt; returns a new empty union find data structure. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:1522&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; create : &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt; &amp;#X2192; t&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
&lt;code&gt;singleton t e d&lt;/code&gt; adds a new element &lt;code&gt;e&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;, and create and
returns a new partition &lt;code&gt;p&lt;/code&gt; in &lt;code&gt;t&lt;/code&gt;, such that &lt;code&gt;e&lt;/code&gt; is the only
element of &lt;code&gt;p&lt;/code&gt;. It also attach the description &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.&lt;/P&gt;&lt;P&gt;The safe version checks that &lt;code&gt;e&lt;/code&gt; was not previously added to
another union-find data structure (with the same link). 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:1879&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; singleton : t &amp;#X2192; element &amp;#X2192; description &amp;#X2192; partition&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
&lt;code&gt;find t e&lt;/code&gt; returns the partition &lt;code&gt;p&lt;/code&gt; of &lt;code&gt;t&lt;/code&gt; that contains &lt;code&gt;e&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:2010&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; find : t &amp;#X2192; element &amp;#X2192; partition&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
&lt;code&gt;union t p1 p2 d&lt;/code&gt; creates a new partition &lt;code&gt;p3&lt;/code&gt;, with description
&lt;code&gt;d&lt;/code&gt;, that contains the union of all the elements in &lt;code&gt;p1&lt;/code&gt; and
&lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; arguments are consumed, i.e. must not be
used after they were passed to &lt;code&gt;union&lt;/code&gt;. &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; must be
different partitions. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:2353&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; union : t &amp;#X2192; partition &amp;#X2192; partition &amp;#X2192; description &amp;#X2192; partition&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
&lt;code&gt;description t p&lt;/code&gt; returns the description associated to &lt;code&gt;p&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:2493&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; description : t &amp;#X2192; partition &amp;#X2192; description&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;  
&lt;code&gt;description t p&lt;/code&gt; changes the description associated to &lt;code&gt;p&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:2613&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; set_description : t &amp;#X2192; partition &amp;#X2192; description &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;2.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.mli:2682&quot;&gt;&lt;/A&gt;We defined two types of &quot;union-find makers&quot;: Fast and Safe. Both
propose a &lt;code&gt;link&lt;/code&gt; type, and each element of a union-find structure
must be &quot;associated&quot; to one different link (generally the link is a
mutable field in the element type). Initially, the link value is
&lt;code&gt;empty_link&lt;/code&gt;.&lt;/P&gt;&lt;P&gt;The &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;&lt;/code&gt; functor, once told how access the link of an element,
returns a module complying to &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;S&lt;/span&gt;&lt;/code&gt;. Below we given an exemple of
usage.&lt;/P&gt;&lt;P&gt;Note: It is possible for an element to be present in two different
union-find data structures; it must just have different links. &lt;/P&gt;&lt;P&gt;If the link in an element must be re-used for another union-find
data structure, then it must be set to &lt;code&gt;empty_link&lt;/code&gt;, and one must
stop using the union-find data structure that contained the element
(even with other elements). 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:3488&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;UNION_FIND&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;sig&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; (&amp;#X3B1;, &amp;#X3B2;) link&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; empty_link:(&amp;#X3B1;,&amp;#X3B2;) link&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.mli:3569&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;LINK&lt;/span&gt; =&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;sig&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; get : element &amp;#X2192; (description, element) link&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; set : element &amp;#X2192; (description, element) link &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.mli:3755&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Link&lt;/span&gt; : &lt;span style=&quot;color: #228b22; &quot;&gt;LINK&lt;/span&gt;):&lt;span style=&quot;color: #228b22; &quot;&gt;S&lt;/span&gt; &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description = &lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;description &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element = &lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;element&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
The difference between the fast and safe version is that safe
performs additional checks. The performance difference is small, so
the Safe version should be prefered. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.mli:4041&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Fast&lt;/span&gt;:&lt;span style=&quot;color: #228b22; &quot;&gt;UNION_FIND&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.mli:4066&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Safe&lt;/span&gt;:&lt;span style=&quot;color: #228b22; &quot;&gt;UNION_FIND&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;3.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.mli:4094&quot;&gt;&lt;/A&gt;Exemple of usage:&lt;/P&gt;&lt;P&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; test = { x:&lt;span style=&quot;color: #228b22; &quot;&gt;int&lt;/span&gt;; &lt;span style=&quot;color: #a020f0; &quot;&gt;mutable&lt;/span&gt; z:(&lt;span style=&quot;color: #228b22; &quot;&gt;string&lt;/span&gt;, test) &lt;span style=&quot;color: #228b22; &quot;&gt;Union_find&lt;/span&gt;.&lt;span style=&quot;color: #228b22; &quot;&gt;Safe&lt;/span&gt;.link };;&lt;/code&gt;&lt;/P&gt;&lt;P&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Test&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description = &lt;span style=&quot;color: #228b22; &quot;&gt;string&lt;/span&gt;
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element = test
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; get_link t = t.z
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; set_link t z = t.z &amp;#X2190; z
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/P&gt;&lt;P&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;A&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Union_find&lt;/span&gt;.&lt;span style=&quot;color: #228b22; &quot;&gt;Safe&lt;/span&gt;.&lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Test&lt;/span&gt;)&lt;/code&gt;&lt;/P&gt;&lt;P&gt;&lt;code&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; uf = &lt;span style=&quot;color: #228b22; &quot;&gt;A&lt;/span&gt;.create() &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; elt1 = {x=1; z=&lt;span style=&quot;color: #228b22; &quot;&gt;Safe&lt;/span&gt;.empty_link} &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;
 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; part1 = &lt;span style=&quot;color: #228b22; &quot;&gt;A&lt;/span&gt;.singleton t elt1 &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;
 &lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;A&lt;/span&gt;.description t (&lt;span style=&quot;color: #228b22; &quot;&gt;A&lt;/span&gt;.find t elt1) = &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;1&quot;&lt;/span&gt;)&lt;/code&gt; 
&lt;BR&gt;&lt;/P&gt;&lt;!--CUT END --&gt;

&lt;!--CUT DEF section 1 --&gt;&lt;!--TOC section Module Union_find--&gt;
&lt;H2 CLASS=&quot;section&quot;&gt;&lt;!--SEC ANCHOR --&gt;Module Union_find&lt;/H2&gt;&lt;!--SEC END --&gt;&lt;P&gt;
&lt;B&gt;1.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:0&quot;&gt;&lt;/A&gt;&lt;A NAME=&quot;src/support/union_find.ml:41&quot;&gt;&lt;/A&gt;We represent each disjoint set by a tree : elements are in the
same set than the element that they point to.&lt;/P&gt;&lt;P&gt;The root of the tree is the representative of the set, and
corresponds to elements of type &lt;code&gt;partition&lt;/code&gt;. It points to a
&quot;partition descriptor&quot;. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:307&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; (&amp;#X3B1;,&amp;#X3B2;) baselink = &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Partition_descriptor&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &amp;#X3B1; partition_descriptor&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &amp;#X3B2;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
The partition descriptor contains the user-accessible description,
and a rank, used to optimize the union operation.&lt;/P&gt;&lt;P&gt;Note that the partition descriptor is not accessible by the users
of the module, and the interface make it so that there can be only
one link to the partition descriptor (from the representative).
This allows to update the partition descriptor destructively. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:825&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; &amp;#X3B1; partition_descriptor = { &lt;span style=&quot;color: #a020f0; &quot;&gt;mutable&lt;/span&gt; rank:rank; &lt;span style=&quot;color: #a020f0; &quot;&gt;mutable&lt;/span&gt; desc:&amp;#X3B1; }&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
The rank of a partition is is a majorant of the distance of its
elements to the root (path compression makes so that the height of
the tree can be lower than the rank). The union operation minimizes
the rank, and thus the height of the tree. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:1152&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; rank = &lt;span style=&quot;color: #228b22; &quot;&gt;int&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;2.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:1172&quot;&gt;&lt;/A&gt;The implementation is parametrized by the safety checks that we
perform (which differs between the Fast and Safe modules). &lt;/P&gt;&lt;P&gt;The safe module identifies all union-find data structures by a
unique id, embed that in the links, and checks for all operation
that they are equal. It also checks initialization of the link. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:1504&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;SAFETY&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;sig&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; create: &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt; &amp;#X2192; t&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; (&amp;#X3B1;,&amp;#X3B2;) link&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:1583&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Create a safe link from a baselink.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; securize: t &amp;#X2192; (&amp;#X3B1;,&amp;#X3B2;) baselink &amp;#X2192; (&amp;#X3B1;,&amp;#X3B2;) link&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:1683&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Returns the base_link from the safe link.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; get_base: (&amp;#X3B1;,&amp;#X3B2;) link &amp;#X2192; (&amp;#X3B1;,&amp;#X3B2;) baselink&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:1784&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Check the safe link withat the element (and the safe link) belong to t.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; check_membership: t &amp;#X2192; (&amp;#X3B1;,&amp;#X3B2;) link &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:1916&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Check that the element is not yet part of any union find.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; check_unused: (&amp;#X3B1;,&amp;#X3B2;) link &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2025&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Initial link.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; empty_link: (&amp;#X3B1;,&amp;#X3B2;) link&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2086&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;No_safety&lt;/span&gt;:&lt;span style=&quot;color: #228b22; &quot;&gt;SAFETY&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; create() = ()&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; (&amp;#X3B1;,&amp;#X3B2;) link = (&amp;#X3B1;,&amp;#X3B2;) baselink&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2196&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; securize () l = l&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2222&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; check_membership () l = ()&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2257&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; check_unused l = ()&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2285&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; get_base l = l&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2308&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Note: This cast can make the execution fail without notice.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; empty_link = &lt;span style=&quot;color: #228b22; &quot;&gt;Obj.&lt;/span&gt;magic 0 &lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2423&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; unique = &lt;span style=&quot;color: #228b22; &quot;&gt;int&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2442&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Unique&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Unique.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2483&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Safety&lt;/span&gt;:&lt;span style=&quot;color: #228b22; &quot;&gt;SAFETY&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = &lt;span style=&quot;color: #228b22; &quot;&gt;Unique.&lt;/span&gt;t&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; create() = &lt;span style=&quot;color: #228b22; &quot;&gt;Unique.&lt;/span&gt;fresh()&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2567&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; (&amp;#X3B1;,&amp;#X3B2;) link = t &lt;span style=&quot;color: #228b22; &quot;&gt;option&lt;/span&gt; × (&amp;#X3B1;,&amp;#X3B2;) baselink&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2619&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; securize u l = (&lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt; u,l)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2653&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; check_membership t (u,_) = &lt;BR&gt;    
(&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; u &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;      
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(a) &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt; (t &amp;#X2261; a) &lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  The element is in another union-find structure.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;      
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt; &lt;span style=&quot;color: #a020f0; &quot;&gt;false&lt;/span&gt;); () &lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  The element is in no union-find structure.  &amp;#X2217;)&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:2882&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; check_unused (u,_) = &lt;BR&gt;    
(&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; u &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;      
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(_) &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt; &lt;span style=&quot;color: #a020f0; &quot;&gt;false&lt;/span&gt; &lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  The element is already in a union-find structure.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;      
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt; &amp;#X2192; ())&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:3041&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; get_base (_,l) = l&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:3068&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Note: The cast is not dangerous, because the left-hand part is
checked first.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; empty_link = (&lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt;, &lt;span style=&quot;color: #228b22; &quot;&gt;Obj.&lt;/span&gt;magic 0) &lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;3.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:3207&quot;&gt;&lt;/A&gt;The goal of the below &quot;double functor&quot; is to produce a module with
the following signature. In it, &lt;code&gt;partition&lt;/code&gt; and &lt;code&gt;element&lt;/code&gt; are
actually the same underlying type; the difference is that elements
returned with type &lt;code&gt;partition&lt;/code&gt; are the root of the tree). Hiding
this in the interface provides some guarantee that arguments of type
partition are the representative of their partition.&lt;/P&gt;&lt;P&gt;Unfortunately, after calling &lt;code&gt;union&lt;/code&gt; on two partitions &lt;code&gt;p1&lt;/code&gt; and
&lt;code&gt;p2&lt;/code&gt;, one of them will stop being the root; that is why the
partition arguments of &lt;code&gt;union&lt;/code&gt; must not be re-used. Thus, defining
the &lt;code&gt;partition&lt;/code&gt; type only guarantees that the argument has been a
root in the past, and we ensure that by a dynamic test. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:3929&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;S&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;sig&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; partition&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; create: &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt; &amp;#X2192; t&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; singleton : t &amp;#X2192; element &amp;#X2192; description &amp;#X2192; partition&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; find : t &amp;#X2192; element &amp;#X2192; partition&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; union: t &amp;#X2192; partition &amp;#X2192; partition &amp;#X2192; description &amp;#X2192; partition&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; description: t &amp;#X2192; partition &amp;#X2192; description&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; set_description : t &amp;#X2192; partition &amp;#X2192; description &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
This is a double functor with two arguments; &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Saf&lt;/span&gt;&lt;/code&gt; allows to
differenciate the &quot;Fast&quot; and &quot;Safe&quot; modules, while &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Link&lt;/span&gt;&lt;/code&gt; is used
to find and change the link. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:4980&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Saf&lt;/span&gt;:&lt;span style=&quot;color: #228b22; &quot;&gt;SAFETY&lt;/span&gt;):&lt;span style=&quot;color: #228b22; &quot;&gt;UNION_FIND&lt;/span&gt; = &lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:5026&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; (&amp;#X3B1;,&amp;#X3B2;) link = (&amp;#X3B1;,&amp;#X3B2;) &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;link&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:5067&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; empty_link = &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;empty_link&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:5104&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;LINK&lt;/span&gt; = &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;sig&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; get: element &amp;#X2192; (description, element) link &lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; set: element &amp;#X2192; (description, element) link &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;unit&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:5290&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Link&lt;/span&gt;: &lt;span style=&quot;color: #228b22; &quot;&gt;LINK&lt;/span&gt;) =&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;t&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; element = &lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;element&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; description = &lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;description&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; partition = &lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;element&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:5453&quot;&gt;&lt;/A&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; create = &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;create&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;4.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:5490&quot;&gt;&lt;/A&gt;&lt;code&gt;singleton&lt;/code&gt; is the only way to add new elements to the
union-find structure, and is the place where we check that the
element is not part of another structure. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:5667&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; singleton t elt desc = &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; l = (&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;get elt) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;check_unused l;&lt;BR&gt;      
&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;set elt (&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;securize t (&lt;span style=&quot;color: #228b22; &quot;&gt;Partition_descriptor&lt;/span&gt; {rank=0;desc=desc}));&lt;BR&gt;      
elt &lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;5.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:5856&quot;&gt;&lt;/A&gt;Basically, &lt;code&gt;find&lt;/code&gt; just walks the tree until it finds the root.&lt;/P&gt;&lt;P&gt;But performance is increased if the length of the path is
diminished: traversed nodes are linked to nodes that are closer
to the roof. The possibility we have implemented is path
compression: when the root is found, the elements are changed
to link to the it, so that subsequent calls are faster. We
implemented a tail-recursive version of this algorithm (which
still requires two pass).&lt;/P&gt;&lt;P&gt;Note: there are alternatives to path compression, such that
halving; but in Tarjan&amp;#X2019;s structure the root is linked to
itself, which is not the case here, so halving would require
more checks than in Tarjan&amp;#X2019;s version. Thus we stick with path
compression. &lt;/P&gt;&lt;P&gt;Note: we could perform a lighter check in the safe version by
checking only the argument, and not all recursive calls; this is
probably not worth implementing it, and the heavy check has its
uses. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:6868&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; find t x = &lt;BR&gt;      
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Tail-recursive function to find the root of the algorithm.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;rec&lt;/span&gt; find x = &lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; l = (&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;get x) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;        
&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;check_membership t l;&lt;BR&gt;        
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;get_base l &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Partition_descriptor&lt;/span&gt;(s) &amp;#X2192; x&lt;BR&gt;          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt;(y) &amp;#X2192; find y &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  This is also tail-recursive, but we do not perform the checks
the second time. &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;rec&lt;/span&gt; compress x r = &lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; l = (&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;get x) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;        
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;get_base l &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Partition_descriptor&lt;/span&gt;(s) &amp;#X2192; ()&lt;BR&gt;          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt;(y) &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;set x (&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;securize t (&lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt; r)) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; root = find x &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
compress x root;&lt;BR&gt;      
root&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;6.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:7541&quot;&gt;&lt;/A&gt;The following functions work only when the given element is
the root of a partition, but check that. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:7653&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; get_partition_descriptor t p = &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; l = (&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;get p) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;check_membership t l;&lt;BR&gt;      
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;get_base l &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Partition_descriptor&lt;/span&gt;(s) &amp;#X2192; s&lt;BR&gt;        
&amp;#X2223; _ &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt;(&lt;span style=&quot;color: #a020f0; &quot;&gt;false&lt;/span&gt;) &lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  The element is not a partition.  &amp;#X2217;)&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:7897&quot;&gt;&lt;/A&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; description t x = (get_partition_descriptor t x).desc&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:7962&quot;&gt;&lt;/A&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; set_description t x desc = &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; pd = get_partition_descriptor t x &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
pd.desc &amp;#X2190; desc&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;7.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:8080&quot;&gt;&lt;/A&gt;This function performs the union of two partitions. We use
rank to find which should be the root : we attach the smaller
tree to the root of the larger tree, so as not to increase the
maximum height (i.e. path length) of the resulting tree.&lt;/P&gt;&lt;P&gt;The last argument allows to update the set descriptor along
with this operation.&lt;/P&gt;&lt;P&gt;Note that this function takes partitions as argument; one could
have instead taken any element, and performed the find inside
the function; in particular some efficient algorithms
interleave the find and union operations. The reason why we
take partition arguments is that it avoids a find when we know
that the argument is a partition (for instance when merging
with a just-created singleton), and the user needs to perform a
find to retrieve and merge the description in the algorithms we
use (such as unification). 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:9011&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; union t p1 p2 newdesc =&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;      
This function also checks that p1 and p2 are partitions. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:9114&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; d1 = get_partition_descriptor t p1 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; d2 = get_partition_descriptor t p2 &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;      
Alternatively, the check that p1 and p2 are different could
have been done here. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:9313&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
      
&lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt; (p1 &amp;#X2260; p2);&lt;BR&gt;      
&lt;span style=&quot;color: #a020f0; &quot;&gt;if&lt;/span&gt;( d1.rank &amp;lt; d2.rank) &lt;span style=&quot;color: #a020f0; &quot;&gt;then&lt;/span&gt; &lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;begin&lt;/span&gt; &lt;BR&gt;          
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Keep d2_repr as root. Height of the merge is max(d1_height +1, d2_height) so does not change.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;          
&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;set p1 (&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;securize t (&lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt; p2));&lt;BR&gt;          
d2.desc &amp;#X2190; newdesc;&lt;BR&gt;          
p2&lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #a020f0; &quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #a020f0; &quot;&gt;if&lt;/span&gt; (d1.rank &amp;gt; d2.rank) &lt;span style=&quot;color: #a020f0; &quot;&gt;then&lt;/span&gt;&lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;begin&lt;/span&gt; &lt;BR&gt;          
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Keep d1_repr as root. Height of the merge is max(d2_height +1, d1_height) so does not change.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;          
&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;set p2 (&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;securize t (&lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt; p1));&lt;BR&gt;          
d1.desc &amp;#X2190; newdesc;&lt;BR&gt;          
p1&lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #a020f0; &quot;&gt;else&lt;/span&gt; &lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;begin&lt;/span&gt;&lt;BR&gt;          
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  We choose arbitrarily p1 to be the root. 
         The height may have changed, as all elements in the subset
         with root p2 are 1 step further to the root.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;          
&lt;span style=&quot;color: #228b22; &quot;&gt;Link.&lt;/span&gt;set p2 (&lt;span style=&quot;color: #228b22; &quot;&gt;Saf.&lt;/span&gt;securize t (&lt;span style=&quot;color: #228b22; &quot;&gt;Parent&lt;/span&gt; p1));&lt;BR&gt;          
d1.rank &amp;#X2190; d1.rank + 1; d1.desc &amp;#X2190; newdesc;&lt;BR&gt;          
p1&lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:10180&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;8.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:10189&quot;&gt;&lt;/A&gt;The double-functor is not shown in the exposed interface, and we
only export the following, simpler modules. 
&lt;BR&gt;&lt;A NAME=&quot;src/support/union_find.ml:10305&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Fast&lt;/span&gt;=&lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;No_safety&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;src/support/union_find.ml:10335&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Safe&lt;/span&gt;=&lt;span style=&quot;color: #228b22; &quot;&gt;Make&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Safety&lt;/span&gt;)&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;9.&lt;/B&gt; 
&lt;A NAME=&quot;src/support/union_find.ml:10365&quot;&gt;&lt;/A&gt;For a survey of the implementations of union-find algorithms, one
should read &quot;Worst-Case Analysis of Set Union Algorithms&quot;, by
Tarjan and Van Leeuwen.&lt;/P&gt;&lt;P&gt;Recent performance comparison of these algorithms (and modern
enhancements) can be found in &quot;Experiments on Union-Find Algorithms
for the Disjoint-Set Data Structure&quot;, by Md. Mostofa Ali Patwary,
Jean Blair, Fredrik Manne. 
&lt;BR&gt;&lt;/P&gt;&lt;!--CUT END --&gt;
</description>
      <pubDate>Sun, 07 Oct 2012 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/A-literate-union-find-data-structure</link>
      <guid isPermaLink="true">http://l-lang.org/blog/A-literate-union-find-data-structure</guid>
    </item>
    
    <item>
      <title>CPS to LLVM SSA conversion in literate programming</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
My L compiler's toolchain is now complete, in that every necessary
transformation pass is here. The various passes are parsing,
macro-expansion, type checking and inference, CPS transformation,
closure conversion, and compilation to &lt;a href=&quot;http://llvm.org/docs/LangRef.html&quot;&gt;LLVM instructions&lt;/a&gt;.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
Most of the passes are still simple, and a lot of work remains to
obtain something usable. For instance I do not propagate informations
about locations, so typing error does not explain where the error is.
All values, including integers, are boxed, allocated with malloc and
never freed; and L code cannot call external C functions. The CPS
transformations are not very efficient, and do not carry type
informations. These are the points I am going to improve next.
&lt;/p&gt;

&lt;p&gt;
However having a complete toolchain is nice: it gives a complete
overview so now I know how changing a pass can benefit to both the
above and below layers.
&lt;/p&gt;

&lt;p&gt;
The nice thing about the passes being simple is that they are easy to
understand, so this is a good opportunity to publish the code. To
further improve the comprehension, I have decided for the last pass I
wrote, which is the transformation from CPS to LLVM, to give a try at
&lt;a href=&quot;http://en.wikipedia.org/wiki/Literate_programming&quot;&gt;literate programming&lt;/a&gt;. It basically consists in writing your code in
the manner of a text book.
&lt;/p&gt;

&lt;p&gt;
There is a nice tool to do literate programming in ocaml, named
&lt;a href=&quot;http://www.lri.fr/~filliatr/ocamlweb/&quot;&gt;ocamlweb&lt;/a&gt;. It allows to write the literate parts in standard comments,
so that the Ocaml files can either be compiled or transformed into a
document. The default HTML output of ocamlweb (based on &lt;a href=&quot;http://hevea.inria.fr/&quot;&gt;HEVEA&lt;/a&gt; is not
very nice however, but some configuration allows to improve it. Here
is is mine, that I put in a file &lt;code&gt;heveaprefix.tex&lt;/code&gt;. This file changes
the HTML output of the code parts of OcamlWeb to look like the HTML
output of source code in Emacs Org-mode (to maintain consistency with
this blog).
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-latex&quot;&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Note: The colors code are those of Emacs org-mode output (which I&lt;/span&gt;
&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;think just put those of Emacs).&lt;/span&gt;

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;This makes &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;\url&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt; links as clickables urls.&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\input&lt;/span&gt;{&lt;span style=&quot;color: #008b8b;&quot;&gt;urlhref.hva&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Big code blocks.&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwbegincode&lt;/span&gt;}{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;&amp;lt;div class=&quot;ocamlweb-src&quot;&amp;gt;&amp;lt;code&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwendcode&lt;/span&gt;}{&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/code&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Inline code blocks inside comments (given with [])&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwbegindcode&lt;/span&gt;}{&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;code&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwenddcode&lt;/span&gt;}{&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/code&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Keywords. We distinguish some keywords (those that ``create''&lt;/span&gt;
&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;something, and begin, in blue). We rely on HEVEA native support for&lt;/span&gt;
&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;the ifthen package.&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\newcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanpurple&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;span style=&quot;color: #a020f0; &quot;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}#1&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #a020f0;&quot;&gt;\newcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanred&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;span style=&quot;color: #a52a2a; &quot;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}#1&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #a020f0;&quot;&gt;\newcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}#1&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwkw&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{let}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{and}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{rec}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{in}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{type}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{of}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanred&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{open}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{struct}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{sig}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{functor}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{module}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{val}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{begin}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{end}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanboldblue&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanpurple&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}}}}}}}}}}}}}}}&lt;/span&gt;}


&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Ids that begin in lower case. The textrm command (note: Hevea does&lt;/span&gt;
&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;not know about mathrm) allows non-italic typesetting. We also&lt;/span&gt;
&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;consider failwith as a keyword (even if it is a function that calls&lt;/span&gt;
&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;raise).&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwlowerid&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\ifthenelse&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\equal&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1}{failwith}}{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanpurple&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\textrm&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#1&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;}}}{&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\textrm&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#1&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;}}&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Ids that begin in upper case.&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\newcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spangreen&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;span style=&quot;color: #228b22; &quot;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}#1&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwupperid&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spangreen&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\textrm&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#1&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;}}&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Comments are type set in red, with the leading (* and closing *).&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwbc&lt;/span&gt;}{&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;span style=&quot;color: #b22222&quot;&amp;gt;(&lt;/span&gt;&lt;span style=&quot;color: #ff0000; font-weight: bold;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#X2217; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwec&lt;/span&gt;}{&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml} &lt;/span&gt;&lt;span style=&quot;color: #ff0000; font-weight: bold;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#X2217;)&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Strings are typeset in brown.&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\newcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanbrown&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;span style=&quot;color: #8b2252; &quot;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}#1&lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;%&lt;/span&gt;
&lt;span style=&quot;color: #0000ff;&quot;&gt;\begin&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\end&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{rawhtml}&lt;/span&gt;}
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwstring&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spanbrown&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\textrm&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#1&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;}}&lt;/span&gt;}

&lt;span style=&quot;color: #b22222;&quot;&gt;%% &lt;/span&gt;&lt;span style=&quot;color: #b22222;&quot;&gt;Base types and type variables are in green.&lt;/span&gt;
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwbt&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spangreen&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;\textrm&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;#1&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;}}&lt;/span&gt;}
&lt;span style=&quot;color: #a020f0;&quot;&gt;\renewcommand&lt;/span&gt;{&lt;span style=&quot;color: #0000ff;&quot;&gt;\ocwtv&lt;/span&gt;}[&lt;span style=&quot;color: #a0522d;&quot;&gt;1&lt;/span&gt;]{&lt;span style=&quot;color: #0000ff;&quot;&gt;\spangreen&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;{#1e}&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The compilation command I use to perform the Ocaml to HTML
transformation is:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-sh&quot;&gt;ocamlweb -p &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;\usepackage{hevea}\usepackage{url}&quot;&lt;/span&gt; --no-index &lt;span style=&quot;color: #8b2252;&quot;&gt;\ &lt;/span&gt;
  heveaprefix.tex cps/cpsbase.ml llvm/cpsllvm.mli llvm/cpsllvm.ml &amp;gt; web/cpsllvm.tex &lt;span style=&quot;color: #8b2252;&quot;&gt;\&lt;/span&gt;
&amp;amp;&amp;amp; &lt;span style=&quot;color: #483d8b;&quot;&gt;cd&lt;/span&gt; web &amp;amp;&amp;amp; hevea -I /usr/share/texmf/tex/latex/misc ocamlweb.sty cpsllvm.tex
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Below is the result (no need to explain it since this is literate
programming! :))
&lt;/p&gt;

&lt;p&gt;
Update: Apparently editing the post with blogger's editor mixes up
the HTML, but this should be fixed now.
&lt;/p&gt;

&lt;!--CUT DEF section 1 --&gt;&lt;!--TOC section Module Cpsbase--&gt;
&lt;H2 CLASS=&quot;section&quot;&gt;&lt;!--SEC ANCHOR --&gt;Module Cpsbase&lt;/H2&gt;&lt;!--SEC END --&gt;&lt;P&gt;
&lt;B&gt;1.&lt;/B&gt; 
&lt;A NAME=&quot;cps/cpsbase.ml:0&quot;&gt;&lt;/A&gt;&lt;A NAME=&quot;cps/cpsbase.ml:43&quot;&gt;&lt;/A&gt;These definitions originates from the &quot;compiling with
continuations, continued&quot; paper, by Andrew Kennedy (we currently
use the simplified, non-graph version).&lt;/P&gt;&lt;P&gt;CPS (for continuation passing style) puts constraints on functional
programs so that a function &lt;I&gt;f&lt;/I&gt; never returns; instead it is passed
a continuation &lt;I&gt;k&lt;/I&gt;, which is a function that represents what is
executed on &lt;I&gt;f&lt;/I&gt; has finished its execution. So instead of returning
a value &lt;I&gt;x&lt;/I&gt;, &lt;I&gt;f&lt;/I&gt; &quot;returns&quot; by calling &lt;I&gt;k&lt;/I&gt;(&lt;I&gt;x&lt;/I&gt;). CPS style makes
returning from functions, and more generally control flow,
explicit, at the expense or more verbosity.&lt;/P&gt;&lt;P&gt;This file presents a particular representation of CPS terms that
separates continuations, calling a continuations, variables holding
continations from respectively normal functions, normal function
calls, and normal variables. This distinction allows to compile the
CPS program using a stack (see the &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Cpsllvm&lt;/span&gt;&lt;/code&gt; module for an
implementation of that). &lt;/P&gt;&lt;P&gt;The representation also forces all values (including constants such
as integers) to be held in variables, which simplify later
transformation algorithms.&lt;/P&gt;&lt;P&gt;&lt;BR&gt;&lt;B&gt;2.&lt;/B&gt; 
&lt;A NAME=&quot;cps/cpsbase.ml:1187&quot;&gt;&lt;/A&gt;We define variables and continuation variables a unique, to avoid
any need for alpha conversion. 
&lt;BR&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1291&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;UniqueCPSVarId&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Unique.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1341&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;UniqueCPSContVarId&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Unique.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1396&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; var = &lt;span style=&quot;color: #228b22; &quot;&gt;Var&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;UniqueCPSVarId.&lt;/span&gt;t&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; contvar = &lt;span style=&quot;color: #228b22; &quot;&gt;ContVar&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;UniqueCPSContVarId.&lt;/span&gt;t&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
Many algorithms use sets and maps of variables and continuation
variables. 
&lt;BR&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1565&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;VarMap&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Map.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = var&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; compare = compare&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1642&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;VarSet&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Set.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = var&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; compare = compare&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1719&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;ContVarMap&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Map.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = contvar&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; compare = compare&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1804&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;ContVarSet&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Set.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; t = contvar&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; compare = compare&lt;BR&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;3.&lt;/B&gt; 
&lt;A NAME=&quot;cps/cpsbase.ml:1892&quot;&gt;&lt;/A&gt;Values are primitive objects, held in continuation variables. 
&lt;BR&gt;&lt;A NAME=&quot;cps/cpsbase.ml:1961&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; value = &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Void&lt;/span&gt; &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.&lt;/span&gt;t&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Tuple&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; var &lt;span style=&quot;color: #228b22; &quot;&gt;list&lt;/span&gt; &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Lambda&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; contvar × var × term&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;4.&lt;/B&gt; 
&lt;A NAME=&quot;cps/cpsbase.ml:2191&quot;&gt;&lt;/A&gt;The representation of CPS terms separates continuations from usual
functions. The various terms are:&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;
&lt;B&gt;&lt;I&gt;let&lt;/I&gt;&lt;/B&gt; &lt;I&gt;x&lt;/I&gt; = &lt;I&gt;value&lt;/I&gt;; &lt;I&gt;body&lt;/I&gt; creates a binding to a primitive
value, or to the result of a primitive operation (to be used in
body)&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;&lt;B&gt;&lt;I&gt;let&lt;/I&gt;&lt;/B&gt; &lt;I&gt;k&lt;/I&gt;(&lt;I&gt;x&lt;/I&gt;) = &lt;I&gt;t&lt;/I&gt;; &lt;I&gt;body&lt;/I&gt;  creates a binding to a
continuation &lt;I&gt;k&lt;/I&gt;. &lt;I&gt;x&lt;/I&gt; is bound in &lt;I&gt;t&lt;/I&gt;, but not in &lt;I&gt;body&lt;/I&gt;. The &lt;I&gt;k&lt;/I&gt;
continuation variable is bound both in &lt;I&gt;body&lt;/I&gt; and &lt;I&gt;t&lt;/I&gt; (this allows
loops).&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;&lt;I&gt;k&lt;/I&gt;(&lt;I&gt;x&lt;/I&gt;) calls the &lt;EM&gt;continuation&lt;/EM&gt; &lt;I&gt;k&lt;/I&gt; with &lt;I&gt;x&lt;/I&gt;. It can be
seen as a &quot;jump with argument &lt;I&gt;x&lt;/I&gt;&quot;&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;&lt;I&gt;v&lt;/I&gt;(&lt;I&gt;k&lt;/I&gt;,&lt;I&gt;x&lt;/I&gt;) calls the &lt;EM&gt;function&lt;/EM&gt; &lt;I&gt;v&lt;/I&gt;, &lt;I&gt;k&lt;/I&gt; being the return
continuation, and &lt;I&gt;x&lt;/I&gt; a parameter. &lt;I&gt;v&lt;/I&gt; does not return; instead it
will call &lt;I&gt;k&lt;/I&gt; with the &quot;return value&quot; as a parameter.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;&lt;I&gt;halt&lt;/I&gt;(&lt;I&gt;x&lt;/I&gt;) is used only as a base case, to stop induction. Its
semantics is that it returns the value &lt;code&gt;x&lt;/code&gt;, which is the result of
the computation, to the caller. &lt;/LI&gt;&lt;/UL&gt;&lt;P&gt; 
&lt;BR&gt;&lt;A NAME=&quot;cps/cpsbase.ml:3158&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; term = &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Let_value&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; var × value × term&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Let_primop&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; var × primitive_operation × term&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Let_cont&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; contvar × var × term × term&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Apply_cont&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; contvar × var&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Apply&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; var × contvar × var&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Halt&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; var&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;5.&lt;/B&gt; 
&lt;A NAME=&quot;cps/cpsbase.ml:3626&quot;&gt;&lt;/A&gt;Primitive operations return a value. The various operations do not
take values as parameters (even constants such as int), only
variables: the representation forces all values to be bound in a
variable. This allows a uniform treatment that helps transformation
passes.&lt;/P&gt;&lt;P&gt;The various operations are:&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;&lt;I&gt;x&lt;/I&gt;[&lt;I&gt;i&lt;/I&gt;] get the &lt;I&gt;i&lt;/I&gt;th element out of &lt;I&gt;x&lt;/I&gt;. &lt;I&gt;x&lt;/I&gt; is a variable bound to
a tuple.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;&lt;I&gt;x&lt;/I&gt;&lt;SUB&gt;1&lt;/SUB&gt; &lt;I&gt;op&lt;/I&gt; &lt;I&gt;x&lt;/I&gt;&lt;SUB&gt;2&lt;/SUB&gt; applies binary op to two arguments.&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt;Note that there are no primitive that would allow to write &lt;B&gt;&lt;I&gt;let&lt;/I&gt;&lt;/B&gt; &lt;I&gt;x&lt;/I&gt; = &lt;I&gt;y&lt;/I&gt;, where &lt;I&gt;y&lt;/I&gt; is a variable; thus there cannot be two
variables that directly share the same value.&lt;/P&gt;&lt;P&gt;&lt;BR&gt;&lt;A NAME=&quot;cps/cpsbase.ml:4302&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; primitive_operation = &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Projection&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; var × &lt;span style=&quot;color: #228b22; &quot;&gt;int&lt;/span&gt;&lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Integer_binary_op&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.&lt;/span&gt;integer_binary_op × var × var&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;
&lt;/P&gt;&lt;!--TOC section Interface for module Cpsllvm--&gt;
&lt;H2 CLASS=&quot;section&quot;&gt;&lt;!--SEC ANCHOR --&gt;Interface for module Cpsllvm&lt;/H2&gt;&lt;!--SEC END --&gt;&lt;P&gt;
&lt;B&gt;6.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.mli:0&quot;&gt;&lt;/A&gt;&lt;A NAME=&quot;llvm/cpsllvm.mli:42&quot;&gt;&lt;/A&gt;This module translates CPS representation to the LLVM IR. CPS
terms must observe that&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;
Functions do not have free (unbound) variables or continuation
variables (use closure conversion to get rid of free variables in
functions)&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Constants functions (such as +,&amp;#X2212;) have been &amp;#X3B7;-expanded,
and translated to the use of CPS primitive operations.
&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt;&lt;BR&gt;&lt;B&gt;7.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.mli:457&quot;&gt;&lt;/A&gt;All translations are done using &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm&lt;/span&gt;.global_context()&lt;/code&gt;, and in a
single Llvm module named &lt;code&gt;the_module&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.mli:571&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; the_module : &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;llmodule&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;8.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.mli:605&quot;&gt;&lt;/A&gt;&lt;code&gt;build_nodef name expr&lt;/code&gt; builds an &lt;code&gt;expr&lt;/code&gt;, an expression in CPS form
that is not part of a function, (for instance if it was typed in the
interactive prompt). It is translated to a Llvm function that take
no argument, named &lt;code&gt;name&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.mli:850&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt; build_nodef : &lt;span style=&quot;color: #228b22; &quot;&gt;string&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Cpsbase.&lt;/span&gt;term &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;llvalue&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;
&lt;/P&gt;&lt;!--TOC section Module Cpsllvm--&gt;
&lt;H2 CLASS=&quot;section&quot;&gt;&lt;!--SEC ANCHOR --&gt;Module Cpsllvm&lt;/H2&gt;&lt;!--SEC END --&gt;&lt;P&gt;
&lt;B&gt;9.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:0&quot;&gt;&lt;/A&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:465&quot;&gt;&lt;/A&gt;This module translates a term written in CPS representation to
LLVM instructions in SSA form.&lt;/P&gt;&lt;P&gt;The CPS representations stems from the paper &quot;Compiling with
continuations, continued&quot; by Andrew Kennedy. In particular this
representation separates continuations from standard lambda
functions, which allows calling and returning from functions using
the normal stack.&lt;/P&gt;&lt;P&gt;This module assumes that functions have no free variables (or
continuation variables). Closure conversion removes free variables
from functions. Free continuation variables should never happen
when translating normal terms to CPS.&lt;/P&gt;&lt;P&gt;The module also assumes that the CPS values do not refer to
primitive operations, such as +,-,*,/. Previous passes must
transform calls to primitive operations to &lt;I&gt;let&lt;/I&gt; &lt;I&gt;x&lt;/I&gt; =
&lt;I&gt;primitive&lt;/I&gt;(&lt;I&gt;args&lt;/I&gt;); and &amp;#X3B7;-expand primitive operations passed as
functions (e.g. &lt;I&gt;let&lt;/I&gt; &lt;I&gt;x&lt;/I&gt; = &lt;I&gt;f&lt;/I&gt;() must have been transformed).&lt;/P&gt;&lt;P&gt;To keep things simple in this first version, no external functions
is called (only lambdas defined in the body of the expression, and
primitive operations, can be called). &lt;/P&gt;&lt;P&gt;In addition, all data is boxed, allocated using malloc (and never
freed; this could be improved by using libgc). Unboxed data would
requires to carry typing information in the CPS terms. 
&lt;BR&gt;&lt;B&gt;10.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:1775&quot;&gt;&lt;/A&gt;To get an overview of the translation algorithm, the best is to
understand how the CPS concepts are mapped to the SSA concepts. In
the following, we denote by [&lt;I&gt;x&lt;/I&gt;] the translation of &lt;I&gt;x&lt;/I&gt;.&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Lambda are translated to LLVM functions with one argument and
one return value.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Other values (i.e. int, floats, and tuples) are all translated
boxed. Thus they all have a single llvm type, which is i8 *.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;A CPS variable &lt;I&gt;x&lt;/I&gt; is mapped to a SSA variables (of type
&lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm&lt;/span&gt;.llvalue&lt;/code&gt;). CPS variables are introduced as arguments to lambda
and continuations, and in the &lt;I&gt;let&lt;/I&gt; &lt;I&gt;x&lt;/I&gt; = ...  form.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;A CPS continuation variable &lt;I&gt;k&lt;/I&gt; introduced by &amp;#X3BB; &lt;I&gt;k&lt;/I&gt;. &lt;I&gt;x&lt;/I&gt;. &lt;I&gt;t&lt;/I&gt;
corresponds to the return from the lambda. A call &lt;I&gt;k&lt;/I&gt;(&lt;I&gt;y&lt;/I&gt;) to this
continuation with a value &lt;I&gt;y&lt;/I&gt; is translated to a &quot;ret&quot; instruction
returning the translation of &lt;I&gt;y&lt;/I&gt;.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;A CPS continuation variable &lt;I&gt;k&lt;/I&gt; introduced by &lt;I&gt;let&lt;/I&gt; &lt;I&gt;k&lt;/I&gt;(&lt;I&gt;x&lt;/I&gt;) = &lt;I&gt;t&lt;/I&gt;&lt;SUB&gt;1&lt;/SUB&gt;;
&lt;I&gt;t&lt;/I&gt;&lt;SUB&gt;2&lt;/SUB&gt; is mapped to the SSA basic block [&lt;I&gt;t&lt;/I&gt;1] (of type
&lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm&lt;/span&gt;.basicblock&lt;/code&gt;). The &lt;I&gt;x&lt;/I&gt; formal argument of &lt;I&gt;k&lt;/I&gt; corresponds to a
phi node at the start of [&lt;I&gt;t&lt;/I&gt;1]. A call &lt;I&gt;k&lt;/I&gt;( &lt;I&gt;y&lt;/I&gt; to this continuation
with a value &lt;I&gt;y&lt;/I&gt; is translated to a &quot;jmp&quot; instruction to the basic
block [&lt;I&gt;t&lt;/I&gt;1], that binds [&lt;I&gt;y&lt;/I&gt;] to the phi node at the start of
&lt;code&gt;[t1]&lt;/code&gt;.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;A call &lt;I&gt;f&lt;/I&gt;( &lt;I&gt;k&lt;/I&gt;, &lt;I&gt;x&lt;/I&gt;) of a regular (non-continuation) function &lt;I&gt;f&lt;/I&gt;
with first argument being a continuation variable argument &lt;I&gt;k&lt;/I&gt; and
second argument being a variable &lt;I&gt;v&lt;/I&gt; is translated to a call to
[&lt;I&gt;f&lt;/I&gt;] with argument [&lt;I&gt;x&lt;/I&gt;], followed by the translation of &lt;I&gt;k&lt;/I&gt;( &lt;I&gt;r&lt;/I&gt;),
with &lt;I&gt;r&lt;/I&gt; being the value returned by the call to &lt;I&gt;f&lt;/I&gt;. This is because
after calling a function in the LLVM SA, the control is returned to
the following instruction. LLVM optimization passes like simplifycfg
can optimize this if needed. Note: this allows tail call
optimizations
&lt;A HREF=&quot;http://llvm.org/docs/CodeGenerator.html#tail-calls&quot;&gt;&lt;TT&gt;http://llvm.org/docs/CodeGenerator.html#tail-calls&lt;/TT&gt;&lt;/A&gt; to take
place.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Primitive operations, such as &lt;I&gt;let&lt;/I&gt; &lt;I&gt;x&lt;/I&gt; = &lt;I&gt;primitive&lt;/I&gt;(&lt;I&gt;args&lt;/I&gt;)
are translated to the corresponding LLVM operations.&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt;Note that the SSA representation are well-formed only if &quot;the
definition of a variable &lt;CODE&gt;%x&lt;/CODE&gt; does not dominate all of its uses&quot;
(&lt;A HREF=&quot;http://llvm.org/docs/LangRef.html#introduction&quot;&gt;&lt;TT&gt;http://llvm.org/docs/LangRef.html#introduction&lt;/TT&gt;&lt;/A&gt;). The translation
from a CPS term (without free variables) ensures that. 
&lt;BR&gt;&lt;B&gt;11.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:4115&quot;&gt;&lt;/A&gt;Here is a simplified example of how the translation from CPS to
SSA works.&lt;/P&gt;&lt;P&gt;The CPS code:
&lt;/P&gt;&lt;PRE CLASS=&quot;verbatim&quot;&gt;  let v = 3;
  let k(x) = k(2+x);
  k(11)  &lt;/PRE&gt;&lt;P&gt;Is translated to SSA (ignoring boxing):
&lt;/P&gt;&lt;PRE CLASS=&quot;verbatim&quot;&gt;  entry: 
    v = 3
    n_ = 11
    jmp k

  k:
    x = phi (entry n_) (k o_)
    m_ = 2 
    o_ = m_ + x
    jmp k &lt;/PRE&gt;&lt;P&gt;This shows how &lt;I&gt;k&lt;/I&gt; is translated to a separate basic block, and the
argument &lt;I&gt;x&lt;/I&gt; to a phi node connected to all the uses of &lt;I&gt;k&lt;/I&gt;.&lt;/P&gt;&lt;P&gt;&lt;BR&gt;&lt;B&gt;12.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:4623&quot;&gt;&lt;/A&gt;If one encounters segmentation faults when changing the LLVM
related code, this may be caused by:&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Calling &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm&lt;/span&gt;.build_call&lt;/code&gt; on a value which does not have the
function &lt;code&gt;lltype&lt;/code&gt;, or &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm&lt;/span&gt;.build_gep&lt;/code&gt; with operations that do not
correspond to the lltype of the value.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Calling &lt;code&gt;build_phi&lt;/code&gt; with an empty list of &quot;incoming&quot;.&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;Calling &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;ExecutionEngine&lt;/span&gt;.create the_module&lt;/code&gt; before calling
&lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm_executionengine&lt;/span&gt;.initialize_native_target()&lt;/code&gt; can also segfault.&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt;Using valgrind or gdb allows to quickly locate the problematic Ocaml
Llvm binding.&lt;/P&gt;&lt;P&gt;&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5238&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; context = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;global_context()&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5276&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; the_module = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;create_module context &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;my jitted module&quot;&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5342&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; void_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;void_type context&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5383&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; i32_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;i32_type context&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5422&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; i32star_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;pointer_type i32_type&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5470&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; anystar_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;pointer_type (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;i8_type context)&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:5533&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;open&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Cpsbase&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
&lt;/P&gt;&lt;!--TOC subsection Creating and accessing memory objects--&gt;
&lt;H3 CLASS=&quot;subsection&quot;&gt;&lt;!--SEC ANCHOR --&gt;Creating and accessing memory objects&lt;/H3&gt;&lt;!--SEC END --&gt;&lt;P&gt; 
&lt;BR&gt;&lt;B&gt;13.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:5611&quot;&gt;&lt;/A&gt;These helper functions create or read-from memory object.
Currently LLVM compiles using a very simple strategy: every value is
boxed (including integers and floats). This simplifies compilation a
lot: every value we create has type void *, and we cast the type
from void * according to how we use it.&lt;/P&gt;&lt;P&gt;LLVM does not (yet?) know how to replace heap allocations with stack
allocations, so we should do that (using an escape analysis). But
LLVM has passes that allow promotion of stack allocations to
register (&quot;mem2reg&quot; and &quot;scalarrepl&quot;), so once this is done (plus
passing and returning arguments in registers), many values should be
unboxed by the compiler (and this would not be that inefficient).
Additional performances could then be obtained by monomorphizing the
code. 
&lt;BR&gt;&lt;B&gt;14.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:6417&quot;&gt;&lt;/A&gt;Store &lt;code&gt;llvalue&lt;/code&gt; in heap-allocated memory. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:6464&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_box llvalue name builder = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; lltype = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;type_of llvalue &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; pointer = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_malloc lltype name builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
ignore(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_store llvalue pointer builder);&lt;BR&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_bitcast pointer anystar_type (name ^ &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;box&quot;&lt;/span&gt;) builder&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;15.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:6720&quot;&gt;&lt;/A&gt;Unbox a &lt;code&gt;llvalue&lt;/code&gt; of type &lt;code&gt;lltype&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:6762&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_unbox llvalue lltype name builder = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; typeptr = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;pointer_type lltype &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; castedptr = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_bitcast llvalue typeptr (name ^ &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;castedptr&quot;&lt;/span&gt;) builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_load castedptr (name ^ &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;unbox&quot;&lt;/span&gt;) builder&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;16.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:6998&quot;&gt;&lt;/A&gt;A n-tuple is allocated as an array of n &lt;code&gt;anystar_type&lt;/code&gt;. Each
element of the array contains the llvalue in l. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:7115&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_tuple l builder = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; length = &lt;span style=&quot;color: #228b22; &quot;&gt;List.&lt;/span&gt;length l &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; array_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;array_type anystar_type length &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; pointer = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_malloc array_type &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;tuple&quot;&lt;/span&gt; builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:7300&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; f () (&lt;span style=&quot;color: #228b22; &quot;&gt;int&lt;/span&gt;,elem) = &lt;BR&gt;    
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Note: the first 0 is because pointer is not the start of
the array, but a pointer to the start of the array, that
must thus be dereferenced.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; path = [| (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;const_int i32_type 0); (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;const_int i32_type &lt;span style=&quot;color: #228b22; &quot;&gt;int&lt;/span&gt;) |] &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; gep_ptr = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_gep pointer path &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;gep&quot;&lt;/span&gt; builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;    
ignore(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_store elem gep_ptr builder) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:7690&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;Utils.Int.&lt;/span&gt;fold_with_list f () (0,l);&lt;BR&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_bitcast pointer anystar_type (&lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;tuplecast&quot;&lt;/span&gt;) builder&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;17.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:7798&quot;&gt;&lt;/A&gt;Retrieve an element from a tuple. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:7838&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_letproj pointer i builder = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; stringi = (string_of_int i) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; &lt;BR&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  First we compute an acceptable LLvm type, and cast the pointer to
that type (failure to do that makes &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm&lt;/span&gt;.build_gep&lt;/code&gt; segfault).
As we try to access the ith element, we assume we are accessing
an array of size i+1.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; array_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;array_type anystar_type (i+1) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; arraystar_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;pointer_type array_type &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; cast_pointer = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_bitcast pointer arraystar_type (&lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;castptr&quot;&lt;/span&gt;) builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; gep_ptr = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_gep cast_pointer [| (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;const_int i32_type 0);&lt;BR&gt;                                                
(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;const_int i32_type i) |] &lt;BR&gt;    
(&lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;gep&quot;&lt;/span&gt; ^ stringi) builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; result = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_load gep_ptr (&lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;builder&quot;&lt;/span&gt; ^ stringi) builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
result &lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;18.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:8629&quot;&gt;&lt;/A&gt;Apply primitive operations. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:8663&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_integer_binary_op op a b builder = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_fn = &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; op &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.IAdd&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_add&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.ISub&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_sub&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.IMul&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_mul&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.IDiv&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_udiv &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; a_unbox = (build_unbox a i32_type &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;a&quot;&lt;/span&gt; builder) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; b_unbox = (build_unbox b i32_type &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;b&quot;&lt;/span&gt; builder) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; res = build_fn a_unbox b_unbox &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;bop&quot;&lt;/span&gt; builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
build_box res &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;res&quot;&lt;/span&gt; builder&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;19.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:9101&quot;&gt;&lt;/A&gt;Build a call instruction, casting &lt;code&gt;caller&lt;/code&gt; to a function pointer. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:9172&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_call caller callee builder =&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; function_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;pointer_type (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;function_type anystar_type [| anystar_type |]) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; casted_caller = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_bitcast caller function_type &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;function&quot;&lt;/span&gt; builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; retval = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_call casted_caller [| callee |] &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;retval&quot;&lt;/span&gt; builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
retval&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
&lt;/P&gt;&lt;!--TOC subsection Creating and accessing basic blocks--&gt;
&lt;H3 CLASS=&quot;subsection&quot;&gt;&lt;!--SEC ANCHOR --&gt;Creating and accessing basic blocks&lt;/H3&gt;&lt;!--SEC END --&gt;&lt;P&gt; 
&lt;BR&gt;&lt;B&gt;20.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:9542&quot;&gt;&lt;/A&gt;This special value is used to ensure, via the type checker, that
compilation to LLVM never leaves a basic-block halfly built. LLVM
basic blocks should all end with a terminator instruction; whenever
one is inserted, the function should return &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt;&lt;/code&gt;. When
building non-terminator instructions, the code must continue
building the basic block. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:9913&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; termination = &lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;21.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:9950&quot;&gt;&lt;/A&gt;This creates a new basic block in the current function.&lt;/P&gt;&lt;P&gt;Note that LLVM basic blocks are associated to a parent function,
that we need to retrieve to create a new basic block. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:10137&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; new_block builder = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; current_bb = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;insertion_block builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; the_function = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;block_parent current_bb &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; new_bb = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;append_block context &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;k&quot;&lt;/span&gt; the_function &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
new_bb&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;22.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:10341&quot;&gt;&lt;/A&gt;Returns &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(phi)&lt;/code&gt; if the block already begins with a phi instruction,
or &lt;code&gt;&lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt;&lt;/code&gt; otherwise. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:10442&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; begin_with_phi_node basic_block = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; pos = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;instr_begin basic_block &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; pos &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.At_end&lt;/span&gt;(_) &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt;&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.Before&lt;/span&gt;(inst) &amp;#X2192; &lt;BR&gt;      
(&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;instr_opcode inst &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.Opcode.PHI&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(inst)&lt;BR&gt;        
&amp;#X2223; _ &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt;)&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;23.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:10848&quot;&gt;&lt;/A&gt;This builds a jmp instruction to &lt;code&gt;destination_block&lt;/code&gt;, also passing
the &lt;code&gt;v&lt;/code&gt; value. This is achieved by setting &lt;code&gt;v&lt;/code&gt; as an incoming value
for the phi instruction that begins &lt;code&gt;destination_block&lt;/code&gt;. If
&lt;code&gt;destination_block&lt;/code&gt; does not start with a phi node, then it is the
first time that &lt;code&gt;destination_block&lt;/code&gt; is called, and we create this
phi node. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:11206&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_jmp_to_and_add_incoming destination_block v builder =&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:11271&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; add_incoming_to_block basic_block (value,curblock) = &lt;BR&gt;    
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; begin_with_phi_node basic_block &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;      
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(phi) &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;add_incoming (value,curblock) phi&lt;BR&gt;      
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt; &amp;#X2192; &lt;BR&gt;        
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Temporarily create a builder to build the phi instruction.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;        
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; builder = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;builder_at context (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;instr_begin basic_block) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;        
ignore(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_phi [value,curblock] &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;phi&quot;&lt;/span&gt; builder) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:11674&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; current_basic_block = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;insertion_block builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
add_incoming_to_block destination_block (v, current_basic_block);&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:11803&quot;&gt;&lt;/A&gt;  
ignore(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_br destination_block builder);&lt;BR&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;24.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:11875&quot;&gt;&lt;/A&gt;We use the following sum type to establish a distinction between:
&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;continuation variables bound with lambda: calling them
returns from the function, and the parameter &lt;code&gt;x&lt;/code&gt; of the call &lt;code&gt;k( x)&lt;/code&gt;
is returned;&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;and continuation variables bound with letcont: calling them
jumps to the corresponding basic block, and the parameter &lt;code&gt;x&lt;/code&gt; of
the call &lt;code&gt;k( x)&lt;/code&gt; is passed to the phi node starting this basic
block.&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt; 
The CPS&amp;#X2192;LLVM translation maps continuation variables to &lt;code&gt;dest_type&lt;/code&gt;s.&lt;/P&gt;&lt;P&gt;&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:12429&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; dest_type = &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Ret&lt;/span&gt; &lt;BR&gt;  
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Jmp_to&lt;/span&gt; &lt;span style=&quot;color: #a52a2a; &quot;&gt;of&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;llbasicblock&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
Build a call to a continuation &lt;code&gt;k x&lt;/code&gt;. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:12534&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; build_applycont k x builder = &lt;BR&gt;  
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; k &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Ret&lt;/span&gt; &amp;#X2192; ignore(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_ret x builder); &lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt;&lt;BR&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Jmp_to&lt;/span&gt;(destination) &amp;#X2192; build_jmp_to_and_add_incoming destination x builder&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
&lt;/P&gt;&lt;!--TOC subsection Main CPS term translation--&gt;
&lt;H3 CLASS=&quot;subsection&quot;&gt;&lt;!--SEC ANCHOR --&gt;Main CPS term translation&lt;/H3&gt;&lt;!--SEC END --&gt;&lt;P&gt; 
&lt;BR&gt;
It is important for LLVM that function names are unique. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:12838&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;module&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;UniqueFunctionId&lt;/span&gt; = &lt;span style=&quot;color: #228b22; &quot;&gt;Unique.Make&lt;/span&gt;(&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;struct&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;end&lt;/span&gt;)&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;25.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:12893&quot;&gt;&lt;/A&gt;This function builds the CPS term &lt;code&gt;cps&lt;/code&gt;, in the current block
pointed to by &lt;code&gt;builder&lt;/code&gt;. &lt;code&gt;varmap&lt;/code&gt; maps CPS variables to LLVM
llvalues. &lt;code&gt;contvarmap&lt;/code&gt; maps CPS continuation variables to values of
type &lt;code&gt;contvar_type&lt;/code&gt;.&lt;/P&gt;&lt;P&gt;All the free variables or continuation variables in &lt;code&gt;cps&lt;/code&gt; must be
in &lt;code&gt;contvarmap&lt;/code&gt; or in &lt;code&gt;varmap&lt;/code&gt;. &lt;code&gt;cps&lt;/code&gt; can contain lambda, but they
must not contain any free variables or free continuation variables
(even the one in &lt;code&gt;varmap&lt;/code&gt; and &lt;code&gt;contvarmap&lt;/code&gt;). Closure conversion
deals with this. Note: previously-defined global variables are not
considered free. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:13477&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;rec&lt;/span&gt; build_term cps (contvarmap, varmap) builder =&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;26.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:13537&quot;&gt;&lt;/A&gt;Helper functions to retrieve/add values from/to maps. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:13597&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; lookup_var x = &lt;BR&gt;    
&lt;span style=&quot;color: #a020f0; &quot;&gt;try&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;VarMap.&lt;/span&gt;find x varmap &lt;BR&gt;    
&lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; _ &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;failwith&lt;/span&gt; &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;in lookup&quot;&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:13688&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; lookup_contvar k = &lt;BR&gt;    
&lt;span style=&quot;color: #a020f0; &quot;&gt;try&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;ContVarMap.&lt;/span&gt;find k contvarmap &lt;BR&gt;    
&lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; _ &amp;#X2192; &lt;span style=&quot;color: #a020f0; &quot;&gt;failwith&lt;/span&gt; &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;in contvar lookup&quot;&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:13799&quot;&gt;&lt;/A&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; add_to_varmap var value = &lt;span style=&quot;color: #228b22; &quot;&gt;VarMap.&lt;/span&gt;add var value varmap &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; add_to_contvarmap contvar block = &lt;span style=&quot;color: #228b22; &quot;&gt;ContVarMap.&lt;/span&gt;add contvar (&lt;span style=&quot;color: #228b22; &quot;&gt;Jmp_to&lt;/span&gt; block) contvarmap &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;27.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:13959&quot;&gt;&lt;/A&gt;Converting the term is done by inductive decomposition. There are
three kind of cases: 
&lt;/P&gt;&lt;UL CLASS=&quot;itemize&quot;&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;
those that only build new values (letvalue, letproj,
letprimop...) in the current basic block
&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;those that return a value and end a basic block 
(apply, applycont, and halt)
&lt;/LI&gt;&lt;LI CLASS=&quot;li-itemize&quot;&gt;the one that build a new basic blocks (letcont).
&lt;/LI&gt;&lt;/UL&gt;&lt;P&gt;To keep the implementation simple, all values are boxed (i.e. put
in the heap and accessed through a pointer), and of llvm type &quot;i8
*&quot;. Pointer conversions are done according to the use of the
value. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:14570&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
  
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; cps &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;28.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:14595&quot;&gt;&lt;/A&gt;These cases build a new value, then continue building the
basic block. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:14677&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Let_value&lt;/span&gt;(x, value, body) &amp;#X2192; &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; newllvalue = &lt;BR&gt;        
(&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; value &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; &lt;BR&gt;          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant&lt;/span&gt;(&lt;span style=&quot;color: #228b22; &quot;&gt;Constant.Int&lt;/span&gt; i) &amp;#X2192;&lt;BR&gt;            
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; llvalue = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;const_int i32_type i &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;            
build_box llvalue (&lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;int&quot;&lt;/span&gt; ^ string_of_int i) builder&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:14938&quot;&gt;&lt;/A&gt;          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Tuple&lt;/span&gt;(l) &amp;#X2192;&lt;BR&gt;            
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; llvalues = &lt;span style=&quot;color: #228b22; &quot;&gt;List.&lt;/span&gt;map lookup_var l &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;            
build_tuple llvalues builder&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;          
This build a new function, with private linkage (since
that it can be used only by the current term), which
allows llvm optimizations.&lt;/P&gt;&lt;P&gt;Note that &lt;code&gt;build_function&lt;/code&gt; will use a new builder, so the
lambda can be built in parallel with the current
function. Also it will use new variables and continuation
variable maps (with only the x parameter), so the lambda
expression must not contain any free variables. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:15569&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Lambda&lt;/span&gt;(k,x,body) &amp;#X2192; &lt;BR&gt;            
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; f = build_function &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;lambda&quot;&lt;/span&gt; k x body &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;            
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;set_linkage &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.Linkage.Private&lt;/span&gt; f;&lt;BR&gt;            
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_bitcast f anystar_type &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;lambdacast&quot;&lt;/span&gt; builder&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;          
Expressions such as &lt;code&gt;let x = primitive&lt;/code&gt; should have
been translated into something like &lt;code&gt;let x =  (a,b) -&amp;gt;
primitiveop( a,b)&lt;/code&gt; in previous compilation stage, so
should fail here. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:16024&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
          
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Constant&lt;/span&gt;(c) &amp;#X2192; &lt;BR&gt;            
&lt;span style=&quot;color: #a020f0; &quot;&gt;assert&lt;/span&gt;( &lt;span style=&quot;color: #228b22; &quot;&gt;Constant.&lt;/span&gt;is_function c);&lt;BR&gt;            
&lt;span style=&quot;color: #a020f0; &quot;&gt;failwith&lt;/span&gt; &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;ICE: primitive operations as value in LLVM translation.&quot;&lt;/span&gt;&lt;BR&gt;        
)&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt; build_term body (contvarmap, (add_to_varmap x newllvalue)) builder&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;    
Primitive operations are similar to letvalue. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:16320&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Let_primop&lt;/span&gt;(x,prim,body) &amp;#X2192; &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; result = (&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; prim &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; &lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Integer_binary_op&lt;/span&gt;(op,xa,xb) &amp;#X2192; &lt;BR&gt;          
build_integer_binary_op op (lookup_var xa) (lookup_var xb) builder&lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Projection&lt;/span&gt;(x,i) &amp;#X2192; build_letproj (lookup_var x) i builder&lt;BR&gt;      
) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
build_term body (contvarmap, (add_to_varmap x result)) builder&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;29.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:16917&quot;&gt;&lt;/A&gt;Building new basic blocks. The algorithm first creates an
empty basic block, bound to k, then build body, then build
term (if k is really called), binding x to the phi node.&lt;/P&gt;&lt;P&gt;The tricky part is that the llvm bindings do not allow to create
an &quot;empty&quot; phi node (even if it would, in future implementations
which would not box everything we would still have to know the
llvm type of the phi node, and that llvm type is not known until
we have processed the jumps to that node). So it is the calls to
k that create or change the phi node; no phi node means k is
never called.&lt;/P&gt;&lt;P&gt;Doing the operations in this order ensures that calls to k are
processed before k is built. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:17670&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Let_cont&lt;/span&gt;(k,x,term,body) &amp;#X2192; &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; new_bb = new_block builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; newcvm = add_to_contvarmap k new_bb &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt; = build_term body (newcvm, varmap) builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;position_at_end new_bb builder;&lt;BR&gt;      
(&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; begin_with_phi_node new_bb &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt;&lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt; &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt;&lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(phi) &amp;#X2192; build_term term (newcvm, (add_to_varmap x phi)) builder)&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;B&gt;30.&lt;/B&gt; 
&lt;A NAME=&quot;llvm/cpsllvm.ml:18068&quot;&gt;&lt;/A&gt;Cases that change or create basic blocks. 
&lt;BR&gt;    
Depending on k, applycont either returns or jumps to k. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:18182&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Apply_cont&lt;/span&gt;(k,x) &amp;#X2192; &lt;BR&gt;      
build_applycont (lookup_contvar k) (lookup_var x) builder&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;    
The CPS semantics state that caller should return to k, but
LLVM SSA does not require that calls end basic blocks. So we
just build a call instruction, and then a call to k. LLVM
optimizations will eliminate the superfluous jump if needed. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:18546&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;
    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Apply&lt;/span&gt;(caller,k,callee) &amp;#X2192; &lt;BR&gt;      
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; retval = build_call (lookup_var caller) (lookup_var callee) builder &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;      
build_applycont (lookup_contvar k) retval builder&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:18717&quot;&gt;&lt;/A&gt;    
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Halt&lt;/span&gt;(x) &amp;#X2192; ignore(&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;build_ret (lookup_var x) builder); &lt;span style=&quot;color: #228b22; &quot;&gt;End_of_block&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
Expression built out of a definition are put in a &quot;&lt;code&gt;void -&amp;gt; void&lt;/code&gt;&quot; function. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:18878&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; build_nodef name cpsbody = &lt;BR&gt;  
prepare_build name cpsbody &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:18945&quot;&gt;&lt;/A&gt;
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; build_function name contparam param cpsbody =&lt;BR&gt;  
prepare_build name cpsbody (&lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt; (contparam,param))&lt;/P&gt;&lt;P&gt;&lt;/code&gt;&lt;/div&gt;
Build the function around the main term cpsbody, possibly taking
some parameters k and x. 
&lt;BR&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:19149&quot;&gt;&lt;/A&gt;
&lt;div class=&quot;ocamlweb-src&quot;&gt;&lt;code&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;and&lt;/span&gt; prepare_build name cpsbody param = &lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; params_type = &lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; param &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt; &amp;#X2192; [| |] &amp;#X2223; _ &amp;#X2192; [| anystar_type |] &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; function_type = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;function_type anystar_type params_type &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Note: it is important for LLVM that function names are unique.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; funname = name ^ &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;#&quot;&lt;/span&gt; ^ (&lt;span style=&quot;color: #228b22; &quot;&gt;UniqueFunctionId.&lt;/span&gt;to_string (&lt;span style=&quot;color: #228b22; &quot;&gt;UniqueFunctionId.&lt;/span&gt;fresh())) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; the_function = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;declare_function funname function_type the_module &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; bb = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;append_block context &lt;span style=&quot;color: #8b2252; &quot;&gt;&quot;entry&quot;&lt;/span&gt; the_function &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Note that we use a new builder. We could even build the functions in parallel.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; builder = &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;builder context &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;position_at_end bb builder;&lt;BR&gt;  
&lt;span style=&quot;color: #a020f0; &quot;&gt;try&lt;/span&gt; &lt;BR&gt;    
&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; initial_varmaps = &lt;BR&gt;      
&lt;span style=&quot;color: #a020f0; &quot;&gt;match&lt;/span&gt; param &lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; &lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;None&lt;/span&gt; &amp;#X2192; (&lt;span style=&quot;color: #228b22; &quot;&gt;ContVarMap.&lt;/span&gt;empty, &lt;span style=&quot;color: #228b22; &quot;&gt;VarMap.&lt;/span&gt;empty)&lt;BR&gt;        
&amp;#X2223; &lt;span style=&quot;color: #228b22; &quot;&gt;Some&lt;/span&gt;(k,x) &amp;#X2192; (&lt;span style=&quot;color: #228b22; &quot;&gt;ContVarMap.&lt;/span&gt;singleton k &lt;span style=&quot;color: #228b22; &quot;&gt;Ret&lt;/span&gt;,&lt;BR&gt;                        
&lt;span style=&quot;color: #228b22; &quot;&gt;VarMap.&lt;/span&gt;singleton x (&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;param the_function 0)) &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;&lt;/P&gt;&lt;P&gt;&lt;A NAME=&quot;llvm/cpsllvm.ml:20037&quot;&gt;&lt;/A&gt;    
ignore(build_term cpsbody initial_varmaps builder);&lt;BR&gt;    
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Prints the textual representation of the function to stderr.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;dump_value the_function;&lt;BR&gt;    
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Validate the code we just generated.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;    
&lt;span style=&quot;color: #228b22; &quot;&gt;Llvm_analysis.&lt;/span&gt;assert_valid_function the_function;&lt;BR&gt;    
the_function&lt;BR&gt;  
&lt;span style=&quot;color: #b22222&quot;&gt;(&amp;#X2217;  Normally, no exception should be thrown, be we never know.  &amp;#X2217;)&lt;/span&gt;&lt;BR&gt;  
&lt;span style=&quot;color: #a020f0; &quot;&gt;with&lt;/span&gt; e &amp;#X2192; &lt;span style=&quot;color: #228b22; &quot;&gt;Llvm.&lt;/span&gt;delete_function the_function; raise e&lt;BR&gt;&lt;/code&gt;&lt;/div&gt;&lt;/P&gt;&lt;!--CUT END --&gt;
</description>
      <pubDate>Sat, 25 Aug 2012 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/CPS-to-LLVM-SSA-conversion-in-literate-programming</link>
      <guid isPermaLink="true">http://l-lang.org/blog/CPS-to-LLVM-SSA-conversion-in-literate-programming</guid>
    </item>
    
    <item>
      <title>Incorporating C code in an Ocaml project using Ocamlbuild</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
I am currently developping the code generation phase of my L
programming language, using &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt;. LLVM provides Ocaml bindings for
building LLVM code and executing them, but there are no easy way to
inspect the result of execution when complex data structures are
produced. 
&lt;/p&gt;

&lt;p&gt;
It turned out that writing these C stubs was not hard at all; and &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/manual033.html&quot;&gt;the
OCaml documentation&lt;/a&gt; for doing that is quite good. The most difficult
part was fighting Ocamlbuild to incorporate these C stubs into the
project.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;A simple example project&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
To get started, here is a sample example project with two OCaml file
and one C file. 
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;File &lt;code&gt;toto_c.c&lt;/code&gt;:
&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-c&quot;&gt;&lt;span style=&quot;color: #483d8b;&quot;&gt;#include&lt;/span&gt; &lt;span style=&quot;color: #8b2252;&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #228b22;&quot;&gt;void&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;toto&lt;/span&gt;(&lt;span style=&quot;color: #228b22;&quot;&gt;void&lt;/span&gt;)
{
  printf(&lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;Hello from C\n&quot;&lt;/span&gt;);
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;File &lt;code&gt;toto.ml&lt;/code&gt;:
&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;external&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;toto_a&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: #228b22;&quot;&gt;unit &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; unit &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;toto&quot;&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;

&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;toto_b&lt;/span&gt;&lt;span style=&quot;color: #a0522d;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;()&lt;/span&gt;&lt;span style=&quot;color: #a0522d;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; toto_a&lt;span style=&quot;color: #a52a2a;&quot;&gt;();&lt;/span&gt; toto_a&lt;span style=&quot;color: #a52a2a;&quot;&gt;();;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This file provides the &quot;ocaml part&quot; of the &quot;toto&quot; library: the
additional definition &lt;code&gt;toto_b&lt;/code&gt; is implemented in ml, not in C.
&lt;/p&gt;

&lt;p&gt;
In simpler implementations with no OCaml definition of the library, or
to provide a separation, the &lt;code&gt;external&lt;/code&gt; declarations could be put in a
standalone .mli file (e.g. &lt;code&gt;toto.mli&lt;/code&gt;).
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;File &lt;code&gt;main.ml&lt;/code&gt;:
&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;Test&lt;/span&gt;.toto_a&lt;span style=&quot;color: #a52a2a;&quot;&gt;();;&lt;/span&gt;
&lt;span style=&quot;color: #228b22;&quot;&gt;Test&lt;/span&gt;.toto_b&lt;span style=&quot;color: #a52a2a;&quot;&gt;();;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Notes:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;The &lt;code&gt;-custom&lt;/code&gt; flag allows to build a custom runtime, i.e. to embed
an OCaml interpreterin the &lt;code&gt;test.byte&lt;/code&gt; file, linked with &lt;code&gt;toto.o&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;Here I compiled the c file using &lt;code&gt;gcc&lt;/code&gt;, but it may also be built
using ocamlc (the benefit being that ocamlc passes the correct
include path options to gcc).
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Using ocamlbuild flags&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
A very simple solution can be obtained by passing flags to ocamlbuild:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-bash&quot;&gt;ocamlbuild toto_c.o
ocamlbuild main.byte -lflags -custom,toto_c.o
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This solution could be used, for instance, in a solution that would
use a &quot;Makefile&quot; driver together with ocamlbuild. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;My current &quot;pure ocamlbuild&quot; solution&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
You will not be able to compile this with Ocamlbuild alone
without a custom plugin, which is OCaml code (with regular syntax) to
put in a &lt;code&gt;myocamlbuild.ml&lt;/code&gt; file, that is automatically compiled by
ocamlbuild.
&lt;/p&gt;

&lt;p&gt;
Note: the user manual of ocamlbuild does not explain how to write a
plugin, but the wiki
&lt;a href=&quot;http://brion.inria.fr/gallium/index.php/Ocamlbuild&quot;&gt;http://brion.inria.fr/gallium/index.php/Ocamlbuild&lt;/a&gt; has several pages
that help.
&lt;/p&gt;

&lt;p&gt;
After trying complicated alternatives, the solution I found consisted
in writing a simple plugin adding a &quot;linkdep&quot; parameterized tag. When
the operation is a link, this tag:
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;adds the file to the dependency list (so that it is also built)
&lt;/li&gt;
&lt;li&gt;adds it to the list of files to be linked (for some reason, when the
&quot;link&quot; tag is active, i.e. the command is a link command, then
Ocamlbuild add the files in the dependency list to list of input
files to be linked).
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The ocamlbuild plugin is rather small: just put the following in the
&lt;code&gt;myocamlbuild.ml&lt;/code&gt; file.
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;open&lt;/span&gt; &lt;span style=&quot;color: #228b22;&quot;&gt;Ocamlbuild_plugin&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;

dispatch &lt;span style=&quot;color: #a52a2a;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #a020f0;&quot;&gt;function&lt;/span&gt;
 &lt;span style=&quot;color: #a0522d;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;|&lt;/span&gt; After_rules &lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt;
    pdep &lt;span style=&quot;color: #a52a2a;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;link&quot;&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;]&lt;/span&gt; &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;linkdep&quot;&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #a020f0;&quot;&gt;fun&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;param &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;[&lt;/span&gt;param&lt;span style=&quot;color: #a52a2a;&quot;&gt;])&lt;/span&gt;
  &lt;span style=&quot;color: #a52a2a;&quot;&gt;|&lt;/span&gt; _ &lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;())&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
What this plugin does is &quot;register that whenever the
link and linkdep plugins are set, add the file passed as a parameter
to the linkdep tag to the list of dependencies&quot;.
&lt;/p&gt;

&lt;p&gt;
Then the &lt;code&gt;_tags&lt;/code&gt; file only has to contain this:
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
&amp;lt;*.byte&amp;gt;: linkdep(toto_c.o), custom
&amp;lt;*.native&amp;gt;: linkdep(toto_c.o)
&lt;/pre&gt;

&lt;p&gt;
And the whole application can be simply built with:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-sh&quot;&gt;ocamlbuild main.byte
ocamlbuild main.native
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
When the &lt;code&gt;main.byte&lt;/code&gt; or &lt;code&gt;main.native&lt;/code&gt; files are built (i.e. linked),
the &lt;code&gt;toto_c.o&lt;/code&gt; file is added as a dependency (and to the list of files
that are linked). Additionally, the &lt;code&gt;custom&lt;/code&gt; tag add the &lt;code&gt;-custom&lt;/code&gt;
option to the OCaml linker.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-1&quot;&gt;Linking with a .a library&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-1&quot;&gt;
&lt;p&gt;
If there is a need to link with several C object files, the solution
also allows to use a library as follow:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Create a file name libname.clib containing the list of object files:
for instance my &lt;code&gt;libtoto.clib&lt;/code&gt; contains &lt;code&gt;toto_c.o&lt;/code&gt;
&lt;/li&gt;

&lt;li&gt;Change the tag file to require &lt;code&gt;libtoto.a&lt;/code&gt; instead of &lt;code&gt;toto_c.o&lt;/code&gt;:
the &lt;code&gt;_tags&lt;/code&gt; file become:
&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&quot;example&quot;&gt;
&amp;lt;*.byte&amp;gt;: linkdep(libtoto.a), custom
&amp;lt;*.native&amp;gt;: linkdep(libtoto.a)
&lt;/pre&gt;

&lt;p&gt;
And that's all. Ocamlbuild knows how to build &lt;code&gt;.a&lt;/code&gt; files from &lt;code&gt;.clib&lt;/code&gt;
files, and will add the contents of the &lt;code&gt;.clib&lt;/code&gt; file as dependencies
from the &lt;code&gt;.a&lt;/code&gt; file.
&lt;/p&gt;

&lt;p&gt;
Note that it is important that the library file begins
by &quot;lib&quot;, or the ocamlbuild rules will not work. The command
&lt;code&gt;ocamlbuild -documentation&lt;/code&gt; provides the list of rules.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Possible enhancements&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;p&gt;
There are several possible enhancements that could be brought:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;The scheme presented here is sufficent for simple C stubs, but
compiling more complex c files would require to change &lt;code&gt;CFLAGS&lt;/code&gt; of
the C compiler (in particular the include directories), and add new
libraries to the
lflags. &lt;a href=&quot;http://mancoosi.org/~abate/ocamlbuild-stubs-and-dynamic-libraries&quot;&gt;http://mancoosi.org/~abate/ocamlbuild-stubs-and-dynamic-libraries&lt;/a&gt;
and
&lt;a href=&quot;http://brion.inria.fr/gallium/index.php/Ocamlbuild_example_with_C_stubs&quot;&gt;http://brion.inria.fr/gallium/index.php/Ocamlbuild_example_with_C_stubs&lt;/a&gt;
deal with this problem by changing the plugin to add an
&quot;include_name&quot; flag. I think this idea could be generalized to add a
parametrized include tag.
&lt;/li&gt;

&lt;li&gt;I think it is a pity that one has to tag the final executable with
the linkdep. It would have been cleaner to tag the ml files that
depended on them, such that linking the final executable is
independent on whether one of the module uses a C stub or not. OCaml
&lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/manual033.html#toc142&quot;&gt;provide&lt;/a&gt; a mean to record the list of C library needed for an ocaml
library (.cma), but not with individual (.cmo) objects, so there is
no simple way to do that.
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;
&lt;p&gt;
After spending some time fighting with ocamlbuild, I managed to have a
working, but less-than-satisfactory result: library added to all
targets for instance. And I remember that I had a similar fight to
handle building custom Camlp4 extensions. 
&lt;/p&gt;

&lt;p&gt;
I usually like using Ocamlbuild, that allows building medium-sized
ocaml projects with no or minimum configuration; especially with the
recent support for findlib packages. But I am not a fan of having to
write OCaml code to build my project properly. I think that Ocamlbuild
could get better if more default parametrized tags would be provided,
such as for adding dependencies, compile flags, and so on. But maybe
the &lt;code&gt;_tags&lt;/code&gt; file format is not sufficient for that.
&lt;/p&gt;

&lt;p&gt;
So maybe I should keep the dual make/ocamlbuild solution. It may be
the simplest to maintain, as it does not require a knowledge of the
internals of ocamlbuild that I am likely to forget.
&lt;/p&gt;

&lt;p&gt;
Maybe I should also try using &lt;a href=&quot;http://omake.metaprl.org/index.html&quot;&gt;OMake&lt;/a&gt; instead, that would allow a
unifying solution. And Ocamlbuild will not be the adequate tool for
building L projects anyway, when I will start bootstrapping the
compiler. But OMake seems not to be maintained anymore&amp;#x2026;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      <pubDate>Fri, 10 Aug 2012 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/Incorporating-C-code-in-an-Ocaml-project-using-Ocamlbuild</link>
      <guid isPermaLink="true">http://l-lang.org/blog/Incorporating-C-code-in-an-Ocaml-project-using-Ocamlbuild</guid>
    </item>
    
    <item>
      <title>A typecast with many uses</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
I just finished implementing a new version of a typecast operator for
the L programming language I'm working on. 
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;The problem of the regular cast implementation&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
Typecast is an operator or function, that allows conversion from any
type to any type. From the point of view of evaluation, it acts as the
identity function; it is useful only for typechecking and type
inference. It allows writing things that the type system does not
(yet) support: increasing the expressivity of the type system means
reducing the number of casts.
&lt;/p&gt;

&lt;p&gt;
Note: in some languages (such as C), cast also perform &lt;i&gt;coercion&lt;/i&gt;,
i.e. convert the value to match the requested type. This is not the
case here.
&lt;/p&gt;

&lt;p&gt;
My first implementation of cast consisted in a &lt;code&gt;cast&lt;/code&gt; function which
did nothing but return its argument, and had for type: &lt;code&gt;forall&amp;lt;a,b&amp;gt; a
-&amp;gt; b&lt;/code&gt;. This means that this function can take arguments of any type,
and does not constrain the return type. For instance, &lt;code&gt;cast( 'a') + 1&lt;/code&gt;
converted 'a' to type &lt;code&gt;Int&lt;/code&gt;: &lt;code&gt;cast( 'a')&lt;/code&gt; converts 'a' to some type,
and &lt;code&gt;+&lt;/code&gt; requires a &lt;code&gt;Int&lt;/code&gt; argument.
&lt;/p&gt;

&lt;p&gt;
Other languages have this approach, for instance the OCaml cast
function, named &lt;code&gt;magic&lt;/code&gt; is defined by:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;external&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;magic &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;a &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;b &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;%identity&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
With &lt;code&gt;identity&lt;/code&gt; being a C function that returns its argument. 
&lt;/p&gt;

&lt;p&gt;
The problem with this definition is that it is not possible to express
the result type according to the argument type directly.
&lt;/p&gt;

&lt;p&gt;
For instance, suppose that I want to create a function &lt;code&gt;make_triple:
forall&amp;lt;t&amp;gt; (t,t,t) -&amp;gt; Triple&amp;lt;t&amp;gt;&lt;/code&gt;. The &lt;code&gt;(t,t,t)&lt;/code&gt; and &lt;code&gt;Triple&amp;lt;t&amp;gt;&lt;/code&gt; have
the same machine representation, but they must appear different to the
type system (to implement some &lt;a href=&quot;http://en.wikipedia.org/wiki/nominal_typing&quot;&gt;nominal typing&lt;/a&gt;).
&lt;/p&gt;

&lt;p&gt;
The problem is that this function is &lt;i&gt;polymorphic&lt;/i&gt;:
&lt;code&gt;make_triple(2,3,4)&lt;/code&gt; has type &lt;code&gt;Triple&amp;lt;Int&amp;gt;&lt;/code&gt;, while
&lt;code&gt;make_triple(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&lt;/code&gt; has type &lt;code&gt;Triple&amp;lt;String&amp;gt;&lt;/code&gt;. Without
polymorphism, the problem would be easy to solve. For instance a
&lt;code&gt;make_triple_int&lt;/code&gt; function that works only with &lt;code&gt;Int&lt;/code&gt; is easy to write
with a regular cast (here I used the C notation for cast, (to_type)
expr :
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;def make_triple(a:Int,b:Int,c:Int) = { (Triple&amp;lt;Int&amp;gt;) (a,b,c) }&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
But for a polymorphic function, the result type &lt;code&gt;Triple&amp;lt;t&amp;gt;&lt;/code&gt; depends on
the source type &lt;code&gt;(t,t,t)&lt;/code&gt;. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Cast is an identity function with a given type&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
The solution I found is to have a cast operator in the language, that
acts as an identity function wrt. evaluation, but whose type is given
has an argument. The syntax is &lt;code&gt;cast( exp, type )&lt;/code&gt;, and does as if
&lt;code&gt;exp&lt;/code&gt; was applied to a function, whose type is &lt;code&gt;type&lt;/code&gt;, which does
nothing but returns its argument.
&lt;/p&gt;

&lt;p&gt;
This cast operator solves the problem:
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;def make_triple(a,b,c) = cast( (a,b,c), forall&amp;lt;t&amp;gt; (t,t,t) -&amp;gt; Triple&amp;lt;t&amp;gt;)&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Notice that the classical cast can still be obtained:
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;def my_cast_function(x) = cast( x, forall&amp;lt;a,b&amp;gt; a -&amp;gt; b)&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
Even more interesting is that this new function also allows to
implement &lt;i&gt;type annotation&lt;/i&gt; (that allows to enforce that a given
expression has a certain type, or reduce its generality). For
instance, &lt;code&gt;cast( 3+2, Int -&amp;gt; Int)&lt;/code&gt; allows to check that &lt;code&gt;3+2&lt;/code&gt; has type
Int, without changing its type. In L, type annotation is written
&lt;code&gt;exp:t&lt;/code&gt; (for instance: &lt;code&gt;(3+2):Int&lt;/code&gt;), and is now implemented using this
cast operator.
&lt;/p&gt;

&lt;p&gt;
The implementation is straightforward, being just a special case of
function application.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Alternative implementations&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-3-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-1&quot;&gt;Using standard cast + type annotation&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-1&quot;&gt;
&lt;p&gt;
On the contrary, it is also possible to implement this cast operator
using standard cast + type annotation. For instance in OCaml:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-ocaml&quot;&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;#&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;a triple&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;
&lt;span style=&quot;color: #a52a2a;&quot;&gt;#&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;make_triple&lt;/span&gt;&lt;span style=&quot;color: #a0522d;&quot;&gt; a b c &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt;
    &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;let&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;my_cast&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;:('&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;a &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;a &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;a&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt;a triple &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #228b22;&quot;&gt;Obj&lt;/span&gt;.magic &lt;span style=&quot;color: #a52a2a;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #a020f0;&quot;&gt;fun&lt;/span&gt; &lt;span style=&quot;color: #a0522d;&quot;&gt;x &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span style=&quot;color: #a52a2a;&quot;&gt;)&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;in&lt;/span&gt;
    my_cast &lt;span style=&quot;color: #a52a2a;&quot;&gt;(&lt;/span&gt;a&lt;span style=&quot;color: #a52a2a;&quot;&gt;,&lt;/span&gt;b&lt;span style=&quot;color: #a52a2a;&quot;&gt;,&lt;/span&gt;c&lt;span style=&quot;color: #a52a2a;&quot;&gt;);;&lt;/span&gt;
&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: #0000ff; font-weight: bold;&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;color: #228b22;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color: #a0522d;&quot;&gt;make_triple &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;a &lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;a &lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;a &lt;span style=&quot;color: #a52a2a;&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;'&lt;/span&gt;a triple &lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color: #a020f0;&quot;&gt;fun&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #a52a2a;&quot;&gt;#&lt;/span&gt; make_triple 1 2 3&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;
&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: #228b22;&quot;&gt;int triple &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;&amp;lt;&lt;/span&gt;abstr&lt;span style=&quot;color: #a52a2a;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color: #a52a2a;&quot;&gt;#&lt;/span&gt; make_triple &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;toto&quot;&lt;/span&gt; &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;tata&quot;&lt;/span&gt; &lt;span style=&quot;color: #8b2252;&quot;&gt;&quot;tutu&quot;&lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;;;&lt;/span&gt;
&lt;span style=&quot;color: #a52a2a;&quot;&gt;-&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;:&lt;/span&gt; &lt;span style=&quot;color: #228b22;&quot;&gt;string triple &lt;/span&gt;&lt;span style=&quot;color: #a52a2a;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #a52a2a;&quot;&gt;&amp;lt;&lt;/span&gt;abstr&lt;span style=&quot;color: #a52a2a;&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Still, I found that it was simpler to implement this cast operator
than annotation + the standard cast. Plus, &lt;code&gt;cast&lt;/code&gt; being a special form
in the language, it can be removed at compile time, which is not the
case if it has to call an external identity function.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-3-2&quot;&gt;Using a special &quot;cast&quot; variable&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-3-2&quot;&gt;
&lt;p&gt;
Another possibility would be to implement cast as a special variable.
Instead of writing &lt;code&gt;cast( exp, t1 -&amp;gt; t2)&lt;/code&gt;, one would write:
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;(cast( t))( exp)&lt;/code&gt; (i.e. apply the &quot;cast variable&quot; to exp).
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;cast( t)&lt;/code&gt; would be an identity function of type &lt;code&gt;t&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt; should thus
be a function type).
&lt;/p&gt;

&lt;p&gt;
This implementation would then be even simpler, being just a special case
of variable (e.g. type variable instantation should be performed
here).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Using this cast operator for implementing isorecursive sum types&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;p&gt;
Implementing &lt;a href=&quot;http://en.wikipedia.org/wiki/Recursive_data_type#Isorecursive_types&quot;&gt;isorecursive data types&lt;/a&gt; need such type casts (called
&quot;roll&quot; and &quot;unroll&quot; in standard terminology).
&lt;/p&gt;

&lt;p&gt;
For instance, if I define the &lt;code&gt;List&lt;/code&gt; type as follows:
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;type List&amp;lt;a&amp;gt; = { Nil | Cons(a, List&amp;lt;a&amp;gt;) }&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
The internal representation of &lt;code&gt;Nil&lt;/code&gt; is &lt;code&gt;(0, ())&lt;/code&gt;, the one of
&lt;code&gt;Cons(hd,tl)&lt;/code&gt; is &lt;code&gt;(1, (hd,tl))&lt;/code&gt;. The first element is a &lt;i&gt;tag&lt;/i&gt; allowing
to identify which variant is a given value. The &lt;i&gt;roll&lt;/i&gt; and &lt;i&gt;unroll&lt;/i&gt;
functions are used for type conversion between these internal
representations and the List&amp;lt;a&amp;gt; type.
&lt;/p&gt;

&lt;p&gt;
So here is how the type constructors can be implemented using my new
cast operator:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-l&quot;&gt;def Nil = cast((0,()), forall&amp;lt;a&amp;gt; (Int,())-&amp;gt;List&amp;lt;a&amp;gt;)
def Cons = { (hd,tl) -&amp;gt; cast( (1, (hd,tl)), forall&amp;lt;a&amp;gt; (Int,(a,List&amp;lt;a&amp;gt;))-&amp;gt;List&amp;lt;a&amp;gt;) }
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The destructors can be implemented by reversing the cast:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-l&quot;&gt;def ifisNil = { (list, then_, else_) -&amp;gt; 
  let (num, _) = cast( list, forall&amp;lt;a&amp;gt; List&amp;lt;a&amp;gt; -&amp;gt; (Int, ()));
  if( num == 0) then_() else else_() 
}

def ifisCons = { (list, then_, else_) -&amp;gt; 
  let (num, _) = cast( list, forall&amp;lt;a&amp;gt; List&amp;lt;a&amp;gt; -&amp;gt; (Int, (a, List&amp;lt;a&amp;gt;)));
  if( num == 1) 
   {
      let (_, (hd,tl)) = cast( list, forall&amp;lt;a&amp;gt; List&amp;lt;a&amp;gt; -&amp;gt; (Int, (a, List&amp;lt;a&amp;gt;)));
      then_(hd,tl)       
   }
 else else_() 
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This tests that it works correctly:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-l&quot;&gt;ifisCons( Nil, { (hd,tl) -&amp;gt; hd }, { () -&amp;gt; 0 }) // returns 0
ifisCons( Cons( 3,Nil), { (hd,tl) -&amp;gt; hd }, { () -&amp;gt; 0 }) // returns 3
ifisCons( Cons( 5, Cons( 3, Nil)), { (hd,tl) -&amp;gt; hd }, { () -&amp;gt; 0 }) // returns 5
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This illustrates the purpose of cast: it allows implementing things
not yet available in the type system. Actually the real implementation
of the type constructors/destructor in L will likely rely on this new
cast function.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      <pubDate>Fri, 22 Jun 2012 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/A-typecast-with-many-uses</link>
      <guid isPermaLink="true">http://l-lang.org/blog/A-typecast-with-many-uses</guid>
    </item>
    
    <item>
      <title>Guaranteed optimizations for system programming languages</title>
      <description>&lt;p&gt;

&lt;/p&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;A definition for &quot;system programming language&quot;&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
A system programming language is a language suitable for programming
&lt;b&gt;system software&lt;/b&gt;, like operating system kernels, drivers, or the
runtime of a programming language. I think the most general definition
for a system programming language is:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Given any maximally-optimized assembly code, a system language allows
to write a program which is compiled to be equivalent to that code.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
&quot;Equivalent&quot; depends on the language; in C it means that some
instructions can be reordered or replaced (e.g. replacing
multiplication by shifts and additions), that there can be some
spillin on the stack, and register allocation may be different. But
all memory accesses, and control flow is the same.
&lt;/p&gt;

&lt;p&gt;
So the language can be seen as a &quot;portable assembler&quot;.  System
programming is exactly this: when you write a piece of code, you know
exactly how it could and should be compiled. That's why C is
appreciated by system programmers.
&lt;/p&gt;

&lt;p&gt;
Here is a non-exhaustive list of specific things a system programming
language must allow:
&lt;/p&gt;

&lt;dl class=&quot;org-dl&quot;&gt;
&lt;dt&gt; Control of memory allocation &lt;/dt&gt;&lt;dd&gt;The programmer should be able to
choose whether an object is heap, static, or stack-allocated, is
explicitly freed, reference-counted, or garbage collected,
etc. Note however that control over whether a variable is stack-
or register-allocated is not generally useful.
&lt;/dd&gt;

&lt;dt&gt; Conformance to a binary interface &lt;/dt&gt;&lt;dd&gt;For instance, it is easy to
write C structs and enums that conform to a network packet
header, filesystem directory entry, MMIO maps of a driver, or ELF
section header. In other language, you can conform to an
interface using a library (e.g. OCaml's &lt;code&gt;bitstring&lt;/code&gt;), but you
need to write conversion functions from and to the interface,
which makes the code more complex and inefficient.
&lt;/dd&gt;

&lt;dt&gt; Control over compilation &lt;/dt&gt;&lt;dd&gt;Abstraction are practical for
understandability and factorization, but create
inefficiencies. For instance, a function call has an overhead
that can be avoided when the function is inlined. A system
language allows to write simple, concrete code that gets compiled
exactly to the assembly output one wants.

&lt;p&gt;
For instance, GCC has a &lt;code&gt;always_inline&lt;/code&gt; keyword that forces all
calls to a function to be inlined. This allows things such as
partial application of some arguments to a function, and in
general a way to control the choice between code size and code
efficiency, which is very important for embedded systems.
&lt;/p&gt;

&lt;p&gt;
The compiler's freedom of reordering/removing reads and writes
can be controlled by the &lt;code&gt;volatile&lt;/code&gt; keyword, or insertion of
&quot;fences&quot;, or the recent C11 standard for control over memory
ordering for multithreaded environments.
&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;
Note however that C is not a perfect system programming language. For
instance:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;It does not allow to write &quot;special&quot; assembly instructions inline
in a standard way (although most compilers allow this as an
extension). The only compiler-agnostic way is to write separate
functions for special instructions, which is inefficient.
&lt;/li&gt;

&lt;li&gt;It does not allow to choose which registers are clobbered by a
function, to force local variables to be allocated in a specific
register, or to require that the stack must not be used for a
function. There are specific pieces of system code which have
these kind of requirements (like interrupt routines), and must be
written in assembly because of this.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Also note that the fact that a language can do system programming does
not mean that it cannot be used for high-level programming. For
instance you could have a mean to enforce how memory is allocated, but
have a default choice of garbage collection when you do not care.
&lt;/p&gt;

&lt;p&gt;
Finally, note that the above features can be useful for applicatiion
programming as well: conformance to a binary interface can be used for
processing binary files; and control over compilation and memory
allocation may be useful for the performance-critical parts of a
program.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Guaranteed optimization&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
We consider the following piece of high-level code:
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-l&quot;&gt;def f(x,y) = 
{ let a = g(x,y);
  let b = h(x,y);
  a + b 
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
A system programmer would expect this code to be compiled to something
like this (in the following, &lt;code&gt;rx&lt;/code&gt; are registers).
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-pseudo-asm&quot;&gt;f: 
// x and y are in r1 and r2
r3 &amp;lt;- r1
call g 
r4 &amp;lt;- r1
r1 &amp;lt;- r3
call h
r1 &amp;lt;- add r1,r4 
return
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
But if the language is compiled by a very naïve functional compiler,
the following could happen instead:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Every let is transformed to a lambda abstraction (that create a
closure) + function call. I.e. the code is transformed to (&lt;code&gt;-&amp;gt;&lt;/code&gt;
denotes lambda abstraction, i.e. function creation):
&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-l&quot;&gt;{ a -&amp;gt; { b -&amp;gt; a + b }( h(x,y)) }( g(x,y))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Two functions are created, one is a closure (allocated to
heap). This breaks control over compilation and control of memory
allocation.
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;The + could be a function that corresponds to a typeclass; an
additional &quot;typeclass&quot; argument is passed to the function, and + is
replaced by a function call. This breaks control over compilation
and control of binary interface.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
However, if the compiler ensured that:
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;let-bound variables do not create new functions and are stack- or
register- allocated;
&lt;/li&gt;

&lt;li&gt;When the return types of &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; is &lt;code&gt;Int&lt;/code&gt;, then the &lt;code&gt;+&lt;/code&gt; function
is inlined
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Then compilation would look like the above assembly code. Thus,
&lt;i&gt;guaranteed optimizations allow to combine high-level constructs and
system programming&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Of course a modern functional compiler could produce native code
similar to that of the above. But this would not be guaranteed, unless
the optimization appeared in &lt;b&gt;specification&lt;/b&gt; of the language. The
classical example of such a guaranteed optimization is the tail-call
optimization, that appeared in the specification of the Scheme
programming language, and allowed to remove loops. I think it's time
to take this idea further.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
      <pubDate>Tue, 01 May 2012 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/Guaranteed-optimizations-for-system-programming-languages</link>
      <guid isPermaLink="true">http://l-lang.org/blog/Guaranteed-optimizations-for-system-programming-languages</guid>
    </item>
    
    <item>
      <title>My first blog entry</title>
      <description>&lt;p&gt;

&lt;/p&gt;

&lt;i&gt;
&lt;p&gt;
&lt;b&gt;Update (2013/07/07)&lt;/b&gt;: I no longer use blogger; but org-mode and
jekyll; perhaps someday I will describe my new setup.
&lt;/p&gt;
&lt;/i&gt;

&lt;p&gt;
Today I have decided to create my blog. Seems like the best way to
share some of the ideas I have, and things I find.
&lt;/p&gt;

&lt;!-- end_excerpt --&gt;

&lt;p&gt;
I wanted to use something that would be simple to maintain and
update. My requirements were specifically to :
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Simply automatize posting of new articles written using
&lt;a href=&quot;http://orgmode.org/&quot;&gt;Org-mode&lt;/a&gt;. For those who do not know, org-mode is a fantastic mode
for Emacs that allows to quickly write formatted text using natural
markup rules. I'm so used to writing documents using it that using
any other tool is painful.
&lt;/li&gt;

&lt;li&gt;No need to write CSS, configure a web server, etc. I have done a
lot of that a while ago, but doing it well requires time, so I'd
rather use a simple solution from a hosting service so that I have
nothing to do except writing new entries.
&lt;/li&gt;

&lt;li&gt;Support for comments. An easy solution with low hassle is to serve
files statically, but one of the reason why I create this blog is
that I want to get remarks, useful advices from other skillful
people on the Internet, and share them; for that comments on my
blog entries seem like the best solution. Also, a spam filter for
comments seemed necessary.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
After searching for a while it seems that blogger was an adequate
solution. It accepts pre-formated HTML messages that I can write using
org-mode, and publishing can be done using google command line tools. 
&lt;/p&gt;

&lt;p&gt;
After a while, I have even found Richard Riley's code for automatic
posting of org entries to blogger. It works really well; after some
minimal configuration, I just have to type &lt;code&gt;M-x org-googlecl-blog&lt;/code&gt; in
emacs while in a blog post to have it instantaneously uploaded to
blogger, using the correct tags etc.
&lt;/p&gt;

&lt;p&gt;
His code is here:
&lt;/p&gt;

&lt;p&gt;
&lt;a href=&quot;http://splash-of-open-sauce.blogspot.fr/2011/03/org-googlecl-blogging-to-bloggercom.html&quot;&gt;http://splash-of-open-sauce.blogspot.fr/2011/03/org-googlecl-blogging-to-bloggercom.html&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
(Before that I tried using Andrei Matveyeu's code for automatizing
this from emacs:
&lt;a href=&quot;http://blog.ideabulbs.com/2011/10/howto-publishing-to-blogger-from-emacs.html&quot;&gt;http://blog.ideabulbs.com/2011/10/howto-publishing-to-blogger-from-emacs.html&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Even if it did not works as much well, it contained interesting
informations on how to configure googlecl and blogger.)
&lt;/p&gt;

&lt;p&gt;
So now, I have no excuses left to fill my blog!
&lt;/p&gt;
</description>
      <pubDate>Wed, 04 Apr 2012 00:00:00 +0200</pubDate>
      <link>http://l-lang.org/blog/My-first-blog-entry</link>
      <guid isPermaLink="true">http://l-lang.org/blog/My-first-blog-entry</guid>
    </item>
    
  </channel>
</rss>
